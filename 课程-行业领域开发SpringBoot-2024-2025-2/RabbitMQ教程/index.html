<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RabbitMQ 教程</title>
    <style>
        :root {
            --primary-color: #4CAF50;
            --secondary-color: #388E3C;
            --background-color: #f5f5f5;
            --text-color: #333;
            --card-background: #ffffff;
            --hover-color: #E8F5E9;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            background-color: var(--card-background);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 2.5rem;
        }

        h2 {
            color: var(--primary-color);
            margin: 2rem 0 1rem 0;
            font-size: 1.8rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        h3 {
            color: var(--secondary-color);
            margin: 1.5rem 0 1rem 0;
            font-size: 1.4rem;
        }

        .subtitle {
            color: #666;
            font-size: 1.2rem;
            margin-bottom: 1rem;
        }

        p {
            margin-bottom: 1rem;
        }

        pre {
            background-color: #f8f8f8;
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            border-left: 4px solid var(--primary-color);
            margin: 1rem 0;
        }

        code {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            color: #333;
        }

        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        .card {
            background-color: var(--card-background);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }

        .tip {
            background-color: #E8F5E9;
            border-left: 4px solid var(--primary-color);
            padding: 1rem;
            margin: 1rem 0;
        }

        .tip-title {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .note {
            background-color: #E3F2FD;
            border-left: 4px solid #2196F3;
            padding: 1rem;
            margin: 1rem 0;
        }

        .note-title {
            font-weight: bold;
            color: #2196F3;
            margin-bottom: 0.5rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        table, th, td {
            border: 1px solid #ddd;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: var(--hover-color);
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .toc {
            background-color: var(--card-background);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }

        .toc-title {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .back-to-home {
            display: inline-block;
            margin-top: 2rem;
            padding: 0.5rem 1rem;
            background-color: var(--primary-color);
            color: white;
            text-decoration: none;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }

        .back-to-home:hover {
            background-color: var(--secondary-color);
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>RabbitMQ 教程</h1>
            <p class="subtitle">消息队列中间件</p>
        </div>
    </header>

    <main class="container">
        <div class="toc">
            <div class="toc-title">目录</div>
            <ul>
                <li><a href="#introduction">1. RabbitMQ 概述</a></li>
                <li><a href="#installation">2. 安装和配置</a></li>
                <li><a href="#basic-concepts">3. 基本概念</a></li>
                <li><a href="#exchange-types">4. 交换机类型</a></li>
                <li><a href="#message-patterns">5. 消息模式</a></li>
                <li><a href="#queue-management">6. 队列管理</a></li>
                <li><a href="#message-properties">7. 消息属性</a></li>
                <li><a href="#clustering">8. 集群部署</a></li>
                <li><a href="#monitoring">9. 监控和管理</a></li>
                <li><a href="#best-practices">10. 最佳实践</a></li>
                <li><a href="#message-acknowledgment">11. 消息确认机制</a></li>
                <li><a href="#dead-letter-exchange">12. 死信队列</a></li>
                <li><a href="#spring-amqp">13. Spring AMQP 集成</a></li>
                <li><a href="#error-handling">14. 错误处理与重试机制</a></li>
                <li><a href="#consumer-prefetch">15. 消费者预取与负载均衡</a></li>
            </ul>
        </div>

        <section id="introduction" class="card">
            <h2>1. RabbitMQ 概述</h2>
            <p>RabbitMQ 是一个开源的消息队列中间件，实现了高级消息队列协议（AMQP）。它提供了可靠的消息传递、灵活的路由、集群、高可用性、管理工具等特性。</p>
            
            <h3>1.1 RabbitMQ 的主要特性</h3>
            <ul>
                <li><strong>可靠性</strong>：支持消息持久化、确认机制、发布者确认等</li>
                <li><strong>灵活的路由</strong>：支持多种交换机类型和路由策略</li>
                <li><strong>集群</strong>：支持集群部署，提供高可用性</li>
                <li><strong>管理界面</strong>：提供 Web 管理界面，方便监控和管理</li>
                <li><strong>多协议支持</strong>：支持 AMQP、MQTT、STOMP 等协议</li>
            </ul>

            <h3>1.2 应用场景</h3>
            <ul>
                <li><strong>异步处理</strong>：将耗时操作异步处理，提高系统响应速度</li>
                <li><strong>应用解耦</strong>：通过消息队列解耦系统组件</li>
                <li><strong>流量削峰</strong>：通过消息队列缓冲突发流量</li>
                <li><strong>日志处理</strong>：收集和分发日志消息</li>
                <li><strong>事件驱动</strong>：实现事件驱动的架构</li>
            </ul>

            <div class="tip">
                <div class="tip-title">小提示</div>
                <p>RabbitMQ 是一个成熟的消息队列中间件，被广泛应用于企业级应用中。它的设计理念是"可靠性和灵活性优先"。</p>
            </div>
        </section>

        <section id="installation" class="card">
            <h2>2. 安装和配置</h2>
            
            <h3>2.1 安装 RabbitMQ</h3>
            <p>在不同操作系统上安装 RabbitMQ：</p>
            
            <h4>Windows</h4>
            <pre><code># 使用 Chocolatey 安装
choco install rabbitmq

# 或下载安装包安装
# 访问 https://www.rabbitmq.com/install-windows.html</code></pre>

            <h4>Linux (Ubuntu/Debian)</h4>
            <pre><code># 添加仓库
curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.deb.sh | sudo bash

# 安装 RabbitMQ
sudo apt-get install rabbitmq-server</code></pre>

            <h4>macOS</h4>
            <pre><code># 使用 Homebrew 安装
brew install rabbitmq</code></pre>

            <h3>2.2 启用管理插件</h3>
            <pre><code># 启用管理插件
rabbitmq-plugins enable rabbitmq_management</code></pre>

            <h3>2.3 创建用户和设置权限</h3>
            <pre><code># 创建用户
rabbitmqctl add_user myuser mypassword

# 设置用户标签
rabbitmqctl set_user_tags myuser administrator

# 设置权限
rabbitmqctl set_permissions -p / myuser ".*" ".*" ".*"</code></pre>

            <div class="note">
                <div class="note-title">注意</div>
                <p>默认的管理界面访问地址是 http://localhost:15672，默认用户名和密码都是 guest。</p>
            </div>
        </section>

        <section id="basic-concepts" class="card">
            <h2>3. 基本概念</h2>
            
            <h3>3.1 核心组件</h3>
            <ul>
                <li><strong>Producer</strong>：消息生产者，发送消息到交换机</li>
                <li><strong>Exchange</strong>：交换机，接收消息并根据路由键转发到队列</li>
                <li><strong>Queue</strong>：队列，存储消息</li>
                <li><strong>Binding</strong>：绑定，连接交换机和队列</li>
                <li><strong>Consumer</strong>：消息消费者，从队列接收消息</li>
            </ul>

            <h3>3.2 消息流转过程</h3>
            <ol>
                <li>Producer 发送消息到 Exchange</li>
                <li>Exchange 根据路由规则将消息转发到相应的 Queue</li>
                <li>Queue 存储消息</li>
                <li>Consumer 从 Queue 接收消息</li>
            </ol>

            <h3>3.3 连接和通道</h3>
            <p>在 Java 中创建连接和通道：</p>
            <pre><code>ConnectionFactory factory = new ConnectionFactory();
factory.setHost("localhost");
Connection connection = factory.newConnection();
Channel channel = connection.createChannel();</code></pre>

            <div class="tip">
                <div class="tip-title">小提示</div>
                <p>Channel 是轻量级的连接，可以在一个 Connection 中创建多个 Channel，每个 Channel 代表一个会话。</p>
            </div>
        </section>

        <section id="exchange-types" class="card">
            <h2>4. 交换机类型</h2>
            
            <h3>4.1 Direct Exchange</h3>
            <p>直接交换机，根据路由键精确匹配：</p>
            <pre><code>// 声明交换机
channel.exchangeDeclare("direct_logs", "direct");

// 绑定队列
channel.queueBind(queueName, "direct_logs", "error");
channel.queueBind(queueName, "direct_logs", "warning");
channel.queueBind(queueName, "direct_logs", "info");</code></pre>

            <h3>4.2 Fanout Exchange</h3>
            <p>扇形交换机，广播消息到所有绑定的队列：</p>
            <pre><code>// 声明交换机
channel.exchangeDeclare("logs", "fanout");

// 绑定队列
channel.queueBind(queueName, "logs", "");</code></pre>

            <h3>4.3 Topic Exchange</h3>
            <p>主题交换机，根据路由键模式匹配：</p>
            <pre><code>// 声明交换机
channel.exchangeDeclare("topic_logs", "topic");

// 绑定队列
channel.queueBind(queueName, "topic_logs", "*.orange.*");
channel.queueBind(queueName, "topic_logs", "*.*.rabbit");
channel.queueBind(queueName, "topic_logs", "lazy.#");</code></pre>

            <h3>4.4 Headers Exchange</h3>
            <p>头交换机，根据消息属性匹配：</p>
            <pre><code>// 声明交换机
channel.exchangeDeclare("headers_logs", "headers");

// 绑定队列
Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
args.put("x-match", "any");
args.put("format", "pdf");
args.put("type", "report");
channel.queueBind(queueName, "headers_logs", "", args);</code></pre>

            <div class="note">
                <div class="note-title">注意</div>
                <p>选择合适的交换机类型对于实现消息路由策略至关重要。Direct Exchange 适用于点对点通信，Fanout Exchange 适用于广播，Topic Exchange 适用于模式匹配，Headers Exchange 适用于基于消息属性的路由。</p>
            </div>
        </section>

        <section id="message-patterns" class="card">
            <h2>5. 消息模式</h2>
            
            <h3>5.1 简单模式</h3>
            <p>最基本的消息模式，一个生产者，一个消费者：</p>
            <pre><code>// 生产者
channel.queueDeclare("simple_queue", true, false, false, null);
String message = "Hello World!";
channel.basicPublish("", "simple_queue", null, message.getBytes());

// 消费者
channel.queueDeclare("simple_queue", true, false, false, null);
channel.basicConsume("simple_queue", true, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) {
        String message = new String(body, "UTF-8");
        System.out.println(" [x] Received '" + message + "'");
    }
});</code></pre>

            <h3>5.2 工作队列模式</h3>
            <p>一个生产者，多个消费者：</p>
            <pre><code>// 生产者
String message = "Hello World!";
channel.basicPublish("", "task_queue", null, message.getBytes());

// 消费者
channel.basicConsume(queueName, true, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) {
        String message = new String(body, "UTF-8");
        System.out.println(" [x] Received '" + message + "'");
    }
});</code></pre>

            <h3>5.3 发布/订阅模式</h3>
            <p>一个生产者，多个消费者，每个消费者收到所有消息：</p>
            <pre><code>// 生产者
channel.exchangeDeclare("logs", "fanout");
String message = "Hello World!";
channel.basicPublish("logs", "", null, message.getBytes());

// 消费者
channel.exchangeDeclare("logs", "fanout");
String queueName = channel.queueDeclare().getQueue();
channel.queueBind(queueName, "logs", "");
channel.basicConsume(queueName, true, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) {
        String message = new String(body, "UTF-8");
        System.out.println(" [x] Received '" + message + "'");
    }
});</code></pre>

            <h3>5.4 路由模式</h3>
            <p>根据路由键将消息发送到特定的队列：</p>
            <pre><code>// 生产者
channel.exchangeDeclare("direct_logs", "direct");
String severity = "error";
String message = "Error message";
channel.basicPublish("direct_logs", severity, null, message.getBytes());

// 消费者
channel.exchangeDeclare("direct_logs", "direct");
String queueName = channel.queueDeclare().getQueue();
channel.queueBind(queueName, "direct_logs", "error");
channel.basicConsume(queueName, true, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) {
        String message = new String(body, "UTF-8");
        System.out.println(" [x] Received '" + message + "'");
    }
});</code></pre>

            <h3>5.5 主题模式</h3>
            <p>使用通配符路由键将消息发送到匹配的队列：</p>
            <pre><code>// 生产者
channel.exchangeDeclare("topic_logs", "topic");
String routingKey = "kern.critical"; // 例如：设备.严重程度
String message = "A critical kernel error";
channel.basicPublish("topic_logs", routingKey, null, message.getBytes());

// 消费者
channel.exchangeDeclare("topic_logs", "topic");
String queueName = channel.queueDeclare().getQueue();

// 可以绑定多个路由键模式
// * 匹配一个单词，# 匹配零个或多个单词
channel.queueBind(queueName, "topic_logs", "kern.*"); // 所有内核消息
channel.queueBind(queueName, "topic_logs", "*.critical"); // 所有严重错误消息
channel.queueBind(queueName, "topic_logs", "kern.#"); // 所有内核相关消息

channel.basicConsume(queueName, true, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) {
        String message = new String(body, "UTF-8");
        String receivedRoutingKey = envelope.getRoutingKey();
        System.out.println(" [x] Received '" + message + "' with routing key '" + 
                          receivedRoutingKey + "'");
    }
});</code></pre>

            <h3>5.6 RPC模式</h3>
            <p>请求/响应模式，客户端发送请求并等待响应：</p>
            <pre><code>// 服务端（RPC服务提供者）
channel.queueDeclare("rpc_queue", false, false, false, null);
channel.basicQos(1); // 每次只处理一个请求
channel.basicConsume("rpc_queue", false, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) throws IOException {
        // 提取相关ID，用于响应
        AMQP.BasicProperties replyProps = new AMQP.BasicProperties
                .Builder()
                .correlationId(properties.getCorrelationId())
                .build();
        
        String response = "";
        try {
            String message = new String(body, "UTF-8");
            int n = Integer.parseInt(message);
            
            // 执行RPC操作（这里是计算斐波那契数列）
            System.out.println(" [x] Received request for fib(" + message + ")");
            response = String.valueOf(fib(n));
        } catch (Exception e) {
            response = "Error: " + e.getMessage();
        } finally {
            // 发送响应到回调队列
            channel.basicPublish("", properties.getReplyTo(), replyProps, response.getBytes());
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
    }
});

// 斐波那契函数示例
private static int fib(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    return fib(n-1) + fib(n-2);
}

// 客户端（RPC调用者）
final String corrId = UUID.randomUUID().toString();
String replyQueueName = channel.queueDeclare().getQueue();
AMQP.BasicProperties props = new AMQP.BasicProperties
        .Builder()
        .correlationId(corrId)
        .replyTo(replyQueueName)
        .build();

// 发送RPC请求
String message = "30"; // 请求计算fib(30)
channel.basicPublish("", "rpc_queue", props, message.getBytes());

// 等待响应
final BlockingQueue&lt;String&gt; response = new ArrayBlockingQueue&lt;&gt;(1);
channel.basicConsume(replyQueueName, true, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) {
        if (properties.getCorrelationId().equals(corrId)) {
            response.offer(new String(body, "UTF-8"));
        }
    }
});

// 获取结果（设置超时）
String result = response.poll(5, TimeUnit.SECONDS);
System.out.println(" [x] Got '" + result + "'");</code></pre>

            <div class="tip">
                <div class="tip-title">小提示</div>
                <p>RabbitMQ提供了六种主要的消息模式，每种适合不同的场景：</p>
                <ul>
                    <li><strong>简单模式</strong>：最基本的点对点通信</li>
                    <li><strong>工作队列模式</strong>：任务分发，适合多消费者处理耗时任务</li>
                    <li><strong>发布/订阅模式</strong>：广播消息，适合一对多通知</li>
                    <li><strong>路由模式</strong>：按照精确的路由键分发消息</li>
                    <li><strong>主题模式</strong>：按照通配符路由键分发消息，最灵活的消息路由</li>
                    <li><strong>RPC模式</strong>：请求/响应，适合需要返回结果的远程调用场景</li>
                </ul>
            </div>
        </section>

        <section id="queue-management" class="card">
            <h2>6. 队列管理</h2>
            
            <h3>6.1 队列声明</h3>
            <p>创建持久化队列：</p>
            <pre><code>boolean durable = true;
channel.queueDeclare("task_queue", durable, false, false, null);</code></pre>

            <h3>6.2 消息持久化</h3>
            <p>发送持久化消息：</p>
            <pre><code>channel.basicPublish("", "task_queue",
    MessageProperties.PERSISTENT_TEXT_PLAIN,
    message.getBytes());</code></pre>

            <h3>6.3 公平调度</h3>
            <p>设置预取计数：</p>
            <pre><code>int prefetchCount = 1;
channel.basicQos(prefetchCount);</code></pre>

            <h3>6.4 消息确认</h3>
            <p>手动确认消息：</p>
            <pre><code>channel.basicConsume(queueName, false, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) {
        String message = new String(body, "UTF-8");
        System.out.println(" [x] Received '" + message + "'");
        // 处理消息
        channel.basicAck(envelope.getDeliveryTag(), false);
    }
});</code></pre>

            <div class="note">
                <div class="note-title">注意</div>
                <p>消息持久化需要同时设置队列持久化和消息持久化。在消费者处理消息时，应该使用手动确认模式以确保消息被正确处理。</p>
            </div>
        </section>

        <section id="message-properties" class="card">
            <h2>7. 消息属性</h2>
            
            <h3>7.1 基本属性</h3>
            <p>设置消息属性：</p>
            <pre><code>AMQP.BasicProperties props = new AMQP.BasicProperties.Builder()
    .contentType("text/plain")
    .contentEncoding("UTF-8")
    .headers(new HashMap&lt;String, Object&gt;())
    .deliveryMode(2) // 持久化消息
    .priority(1)
    .correlationId("correlation-id")
    .replyTo("reply-queue")
    .expiration("60000") // 消息过期时间（毫秒）
    .messageId("message-id")
    .timestamp(new Date())
    .type("message-type")
    .userId("user-id")
    .appId("app-id")
    .build();

channel.basicPublish("", "queue-name", props, message.getBytes());</code></pre>

            <h3>7.2 消息过期时间</h3>
            <p>设置消息过期时间：</p>
            <pre><code>AMQP.BasicProperties props = new AMQP.BasicProperties.Builder()
    .expiration("60000") // 60秒后过期
    .build();</code></pre>

            <h3>7.3 消息优先级</h3>
            <p>设置消息优先级：</p>
            <pre><code>AMQP.BasicProperties props = new AMQP.BasicProperties.Builder()
    .priority(5) // 优先级范围 0-9
    .build();</code></pre>

            <div class="tip">
                <div class="tip-title">小提示</div>
                <p>消息属性可以帮助实现更复杂的消息处理逻辑，如消息过期、优先级处理、消息追踪等。</p>
            </div>
        </section>

        <section id="clustering" class="card">
            <h2>8. 集群部署</h2>
            
            <h3>8.1 集群配置</h3>
            <p>配置集群节点：</p>
            <pre><code># 在节点1上
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl start_app

# 在节点2上
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl join_cluster rabbit@node1
rabbitmqctl start_app</code></pre>

            <h3>8.2 镜像队列</h3>
            <p>配置镜像队列：</p>
            <pre><code># 设置镜像策略
rabbitmqctl set_policy ha-all ".*" '{"ha-mode":"all"}'</code></pre>

            <h3>8.3 集群管理</h3>
            <p>查看集群状态：</p>
            <pre><code># 查看集群状态
rabbitmqctl cluster_status

# 查看节点信息
rabbitmqctl list_cluster_nodes</code></pre>

            <div class="note">
                <div class="note-title">注意</div>
                <p>在集群环境中，应该使用镜像队列来确保消息的高可用性。同时，应该注意网络分区的情况，并配置适当的处理策略。</p>
            </div>
        </section>

        <section id="monitoring" class="card">
            <h2>9. 监控和管理</h2>
            
            <h3>9.1 管理界面</h3>
            <p>访问管理界面：</p>
            <ul>
                <li>URL：http://localhost:15672</li>
                <li>默认用户名：guest</li>
                <li>默认密码：guest</li>
            </ul>

            <h3>9.2 监控指标</h3>
            <ul>
                <li><strong>队列状态</strong>：消息数量、消费者数量、内存使用等</li>
                <li><strong>消息速率</strong>：发布速率、消费速率</li>
                <li><strong>连接状态</strong>：连接数、通道数</li>
                <li><strong>资源使用</strong>：内存使用、磁盘使用</li>
            </ul>

            <h3>9.3 告警配置</h3>
            <p>配置告警规则：</p>
            <pre><code># 设置内存告警阈值
rabbitmqctl set_vm_memory_high_watermark 0.8

# 设置磁盘告警阈值
rabbitmqctl set_disk_free_limit "100MB"</code></pre>

            <div class="tip">
                <div class="tip-title">小提示</div>
                <p>定期监控 RabbitMQ 的状态对于及时发现和解决问题至关重要。建议配置适当的告警机制。</p>
            </div>
        </section>

        <section id="best-practices" class="card">
            <h2>10. 最佳实践</h2>
            
            <h3>10.1 性能优化</h3>
            <ul>
                <li><strong>使用持久化</strong>：对重要消息使用持久化</li>
                <li><strong>合理设置预取数</strong>：根据消费者处理能力设置</li>
                <li><strong>使用批量确认</strong>：适当使用批量确认提高性能</li>
                <li><strong>优化消息大小</strong>：控制消息大小，避免过大的消息</li>
                <li><strong>使用连接池</strong>：复用连接和通道</li>
            </ul>

            <h3>10.2 可靠性保证</h3>
            <ul>
                <li><strong>使用确认机制</strong>：确保消息被正确处理</li>
                <li><strong>实现重试机制</strong>：处理失败的消息</li>
                <li><strong>使用死信队列</strong>：处理无法处理的消息</li>
                <li><strong>实现幂等性</strong>：确保消息处理的幂等性</li>
                <li><strong>监控和告警</strong>：及时发现和处理问题</li>
            </ul>

            <h3>10.3 安全配置</h3>
            <ul>
                <li><strong>修改默认密码</strong>：更改默认的管理员密码</li>
                <li><strong>使用 SSL/TLS</strong>：加密通信</li>
                <li><strong>限制访问权限</strong>：使用最小权限原则</li>
                <li><strong>定期更新</strong>：保持 RabbitMQ 版本更新</li>
                <li><strong>审计日志</strong>：记录重要操作</li>
            </ul>

            <div class="note">
                <div class="note-title">笔记</div>
                <p>遵循最佳实践可以帮助构建可靠、高效、安全的消息队列系统。根据具体需求选择合适的技术和配置。</p>
            </div>
        </section>

        <section id="message-acknowledgment" class="card">
            <h2>11. 消息确认机制</h2>
            
            <h3>11.1 消息确认的重要性</h3>
            <p>消息确认机制是 RabbitMQ 保证消息可靠性的核心机制，它确保消息在处理过程中不会丢失。</p>
            <ul>
                <li><strong>消费者确认</strong>：消费者处理完消息后向 RabbitMQ 发送确认</li>
                <li><strong>发布者确认</strong>：RabbitMQ 收到消息后向发布者发送确认</li>
            </ul>

            <h3>11.2 消费者确认模式</h3>
            <p>RabbitMQ 支持三种消费者确认模式：</p>
            <ol>
                <li><strong>自动确认（Auto Ack）</strong>：消息一旦被发送给消费者，立即从队列中移除</li>
                <li><strong>手动确认（Manual Ack）</strong>：消费者处理完消息后手动发送确认</li>
                <li><strong>批量确认（Batch Ack）</strong>：消费者可以一次性确认多条消息</li>
            </ol>

            <pre><code>// 设置为手动确认模式
boolean autoAck = false;
channel.basicConsume(queueName, autoAck, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) throws IOException {
        String message = new String(body, "UTF-8");
        try {
            // 处理消息
            System.out.println(" [x] Received '" + message + "'");
            // 处理完成后确认
            channel.basicAck(envelope.getDeliveryTag(), false);
        } catch (Exception e) {
            // 处理失败时拒绝消息，并重新入队
            channel.basicNack(envelope.getDeliveryTag(), false, true);
            // 或者拒绝消息，不重新入队
            // channel.basicReject(envelope.getDeliveryTag(), false);
        }
    }
});</code></pre>

            <h3>11.3 发布者确认</h3>
            <p>发布者确认（Publisher Confirms）允许发布者确认消息已被 RabbitMQ 成功接收：</p>
            <pre><code>// 启用发布者确认模式
channel.confirmSelect();

// 同步等待确认
channel.basicPublish("", queueName, null, message.getBytes());
if (channel.waitForConfirms()) {
    System.out.println("消息已确认");
} else {
    System.out.println("消息未确认");
}

// 异步确认
channel.addConfirmListener(new ConfirmListener() {
    @Override
    public void handleAck(long deliveryTag, boolean multiple) {
        System.out.println("消息已确认: " + deliveryTag);
    }

    @Override
    public void handleNack(long deliveryTag, boolean multiple) {
        System.out.println("消息未确认: " + deliveryTag);
    }
});</code></pre>

            <h3>11.4 事务机制</h3>
            <p>RabbitMQ 也支持事务机制，但性能较低，一般不推荐使用：</p>
            <pre><code>// 开启事务
channel.txSelect();

try {
    // 发送消息
    channel.basicPublish("", queueName, null, message.getBytes());
    // 提交事务
    channel.txCommit();
} catch (Exception e) {
    // 回滚事务
    channel.txRollback();
    throw e;
}</code></pre>

            <div class="tip">
                <div class="tip-title">最佳实践</div>
                <p>对于关键业务，推荐使用手动确认模式和发布者确认（Publisher Confirms）机制，而不是使用事务。发布者确认机制性能更好，且提供了异步确认的能力。</p>
            </div>
        </section>

        <section id="dead-letter-exchange" class="card">
            <h2>12. 死信队列</h2>
            
            <h3>12.1 什么是死信队列</h3>
            <p>死信队列（Dead Letter Queue，DLQ）是 RabbitMQ 中处理无法被正常消费的消息的机制。当消息变成死信时，它会被重新发布到指定的死信交换机（Dead Letter Exchange，DLX）。</p>

            <h3>12.2 消息成为死信的情况</h3>
            <ul>
                <li><strong>消息被拒绝（reject/nack）</strong>：消费者拒绝消息并且不将其重新放入队列</li>
                <li><strong>消息过期（TTL）</strong>：消息在队列中的存活时间超过设定的 TTL</li>
                <li><strong>队列达到最大长度</strong>：队列中的消息数量达到最大限制</li>
            </ul>

            <h3>12.3 配置死信队列</h3>
            <p>配置一个带有死信队列的正常队列：</p>
            <pre><code>// 声明死信交换机
channel.exchangeDeclare("dead.letter.exchange", "direct");

// 声明死信队列
channel.queueDeclare("dead.letter.queue", true, false, false, null);

// 绑定死信队列到死信交换机
channel.queueBind("dead.letter.queue", "dead.letter.exchange", "dead.letter.routing.key");

// 为正常队列设置死信交换机
Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
args.put("x-dead-letter-exchange", "dead.letter.exchange");
args.put("x-dead-letter-routing-key", "dead.letter.routing.key");
// 可选：设置消息TTL
args.put("x-message-ttl", 60000); // 60秒
// 可选：设置队列最大长度
args.put("x-max-length", 1000);

// 声明正常队列
channel.queueDeclare("normal.queue", true, false, false, args);</code></pre>

            <h3>12.4 消费者拒绝导致的死信</h3>
            <pre><code>// 消费者拒绝消息
channel.basicConsume("normal.queue", false, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) throws IOException {
        String message = new String(body, "UTF-8");
        try {
            // 处理消息
            if (someCondition) {
                throw new Exception("无法处理该消息");
            }
            // 确认消息
            channel.basicAck(envelope.getDeliveryTag(), false);
        } catch (Exception e) {
            // 拒绝消息，不重新入队，消息将被发送到死信队列
            channel.basicReject(envelope.getDeliveryTag(), false);
        }
    }
});</code></pre>

            <h3>12.5 死信队列的处理</h3>
            <p>消费处理死信队列中的消息：</p>
            <pre><code>// 消费死信队列
channel.basicConsume("dead.letter.queue", false, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope,
                             AMQP.BasicProperties properties, byte[] body) throws IOException {
        String message = new String(body, "UTF-8");
        
        // 记录死信消息
        System.out.println("处理死信消息: " + message);
        
        // 分析消息失败原因，可以通过原始消息的属性获取
        Map&lt;String, Object&gt; headers = properties.getHeaders();
        if (headers != null) {
            String xDeathReason = headers.get("x-death") != null ? 
                                 headers.get("x-death").toString() : "未知原因";
            System.out.println("死信原因: " + xDeathReason);
        }
        
        // 确认死信消息
        channel.basicAck(envelope.getDeliveryTag(), false);
    }
});</code></pre>

            <div class="note">
                <div class="note-title">场景应用</div>
                <p>死信队列在以下场景特别有用：</p>
                <ul>
                    <li>处理无法消费的消息，如格式错误的消息</li>
                    <li>实现消息的延迟处理（通过TTL和死信队列组合）</li>
                    <li>捕获和监控异常情况</li>
                    <li>实现请求的限时响应</li>
                </ul>
            </div>
        </section>

        <section id="spring-amqp" class="card">
            <h2>13. Spring AMQP 集成</h2>
            
            <h3>13.1 Spring AMQP 简介</h3>
            <p>Spring AMQP 提供了一套基于 Spring 框架的 AMQP 抽象，简化了 RabbitMQ 的使用。它包含两个核心模块：</p>
            <ul>
                <li><strong>spring-amqp</strong>：提供核心抽象和通用 AMQP 模型</li>
                <li><strong>spring-rabbit</strong>：提供 RabbitMQ 的具体实现</li>
            </ul>

            <h3>13.2 Maven 依赖</h3>
            <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;version&gt;2.7.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>

            <h3>13.3 基本配置</h3>
            <p>在 Spring Boot 应用中配置 RabbitMQ：</p>
            <pre><code>// application.properties 配置
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/

// Java配置类
@Configuration
public class RabbitMQConfig {

    @Bean
    public Queue queue() {
        return new Queue("my-queue", true);
    }

    @Bean
    public DirectExchange exchange() {
        return new DirectExchange("my-exchange");
    }

    @Bean
    public Binding binding(Queue queue, DirectExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with("my-routing-key");
    }

    @Bean
    public MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory, MessageConverter messageConverter) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(messageConverter);
        return rabbitTemplate;
    }
}</code></pre>

            <h3>13.4 发送消息</h3>
            <p>使用 RabbitTemplate 发送消息：</p>
            <pre><code>@Service
public class MessageProducer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendMessage(String message) {
        rabbitTemplate.convertAndSend("my-exchange", "my-routing-key", message);
    }

    public void sendObjectMessage(MyObject object) {
        rabbitTemplate.convertAndSend("my-exchange", "my-routing-key", object);
    }
}</code></pre>

            <h3>13.5 接收消息</h3>
            <p>使用 @RabbitListener 注解接收消息：</p>
            <pre><code>@Component
public class MessageConsumer {

    @RabbitListener(queues = "my-queue")
    public void receiveMessage(String message) {
        System.out.println("收到消息: " + message);
    }

    @RabbitListener(queues = "my-queue")
    public void receiveObjectMessage(MyObject object) {
        System.out.println("收到对象消息: " + object);
    }
}</code></pre>

            <h3>13.6 高级配置</h3>
            <h4>13.6.1 配置确认回调</h4>
            <pre><code>@Bean
public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
    RabbitTemplate template = new RabbitTemplate(connectionFactory);
    template.setConfirmCallback((correlationData, ack, cause) -> {
        if (ack) {
            System.out.println("消息发送成功");
        } else {
            System.out.println("消息发送失败: " + cause);
        }
    });
    template.setReturnsCallback(returned -> {
        System.out.println("消息被退回: " + 
            "交换机: " + returned.getExchange() + 
            ", 路由键: " + returned.getRoutingKey() +
            ", 原因: " + returned.getReplyText());
    });
    return template;
}

// 启用确认回调
@Bean
public ConnectionFactory connectionFactory() {
    CachingConnectionFactory connectionFactory = new CachingConnectionFactory("localhost");
    connectionFactory.setUsername("guest");
    connectionFactory.setPassword("guest");
    connectionFactory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.CORRELATED);
    connectionFactory.setPublisherReturns(true);
    return connectionFactory;
}</code></pre>

            <h4>13.6.2 配置死信队列</h4>
            <pre><code>@Bean
public Queue orderQueue() {
    Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
    args.put("x-dead-letter-exchange", "order.dead.letter.exchange");
    args.put("x-dead-letter-routing-key", "order.dead");
    args.put("x-message-ttl", 60000); // 1分钟
    return new Queue("order.queue", true, false, false, args);
}

@Bean
public DirectExchange orderExchange() {
    return new DirectExchange("order.exchange");
}

@Bean
public Binding orderBinding() {
    return BindingBuilder.bind(orderQueue()).to(orderExchange()).with("order");
}

@Bean
public Queue deadLetterQueue() {
    return new Queue("order.dead.letter.queue", true);
}

@Bean
public DirectExchange deadLetterExchange() {
    return new DirectExchange("order.dead.letter.exchange");
}

@Bean
public Binding deadLetterBinding() {
    return BindingBuilder.bind(deadLetterQueue()).to(deadLetterExchange()).with("order.dead");
}</code></pre>

            <div class="tip">
                <div class="tip-title">最佳实践</div>
                <p>使用 Spring AMQP 可以大大简化 RabbitMQ 的使用，特别是在 Spring Boot 应用中。利用 Spring 的依赖注入和声明式编程模型，可以更方便地配置和使用消息队列。</p>
            </div>
        </section>

        <section id="error-handling" class="card">
            <h2>14. 错误处理与重试机制</h2>
            
            <h3>14.1 基本错误处理</h3>
            <p>使用 try-catch 捕获消费者处理消息时的异常：</p>
            <pre><code>@RabbitListener(queues = "my-queue")
public void receiveMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long tag) {
    try {
        // 处理消息
        System.out.println("处理消息: " + message);
        // 确认消息
        channel.basicAck(tag, false);
    } catch (Exception e) {
        try {
            // 拒绝消息，重新入队
            channel.basicNack(tag, false, true);
        } catch (IOException ex) {
            // 处理通道异常
        }
    }
}</code></pre>

            <h3>14.2 Spring Retry 集成</h3>
            <p>使用 Spring Retry 实现消息处理的重试机制：</p>
            <pre><code>// 添加依赖
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;

// 配置重试
@Configuration
@EnableRetry
public class RetryConfig {
}

// 在服务中使用重试
@Service
public class OrderService {

    @Retryable(
        value = {OrderProcessException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public void processOrder(Order order) throws OrderProcessException {
        // 处理订单
        if (someCondition) {
            throw new OrderProcessException("订单处理失败");
        }
    }

    @Recover
    public void recoverOrderProcess(OrderProcessException e, Order order) {
        // 重试失败后的恢复处理
        System.out.println("重试失败，执行补偿逻辑: " + order);
    }
}</code></pre>

            <h3>14.3 Spring AMQP 重试机制</h3>
            <p>配置 Spring AMQP 的重试机制：</p>
            <pre><code>@Bean
public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
        ConnectionFactory connectionFactory,
        MessageConverter messageConverter) {
        
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);
    factory.setMessageConverter(messageConverter);
    
    // 配置消费者确认模式
    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);
    
    // 配置重试
    RetryInterceptorBuilder<?> retryInterceptorBuilder = RetryInterceptorBuilder.stateless()
        .maxAttempts(3)
        .backOffOptions(1000, 2.0, 10000)
        .recoverer(new RejectAndDontRequeueRecoverer()); // 重试失败后拒绝消息
    
    factory.setAdviceChain(new Advice[] {retryInterceptorBuilder.build()});
    
    return factory;
}</code></pre>

            <h3>14.4 错误处理策略</h3>
            <p>不同的错误处理策略：</p>
            <ol>
                <li><strong>重试后重新入队</strong>：适用于临时性错误，如网络抖动</li>
                <li><strong>重试后发送到死信队列</strong>：适用于处理失败的消息</li>
                <li><strong>重试后丢弃</strong>：适用于不重要的消息</li>
                <li><strong>记录错误并继续</strong>：适用于可容忍错误的场景</li>
            </ol>

            <pre><code>// 重试后发送到死信队列
@Bean
public MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate) {
    return new RepublishMessageRecoverer(rabbitTemplate, "error.exchange", "error.routing.key");
}</code></pre>

            <div class="note">
                <div class="note-title">最佳实践</div>
                <p>为不同类型的消息和错误设计不同的处理策略。对于重要的业务消息，应该实现重试机制和死信处理；对于非关键消息，可以采用更简单的策略。始终记录错误信息，以便后续分析和改进。</p>
            </div>
        </section>

        <section id="consumer-prefetch" class="card">
            <h2>15. 消费者预取与负载均衡</h2>
            
            <h3>15.1 预取计数的作用</h3>
            <p>预取计数（prefetch count）控制 RabbitMQ 一次发送给消费者的未确认消息数量，对消费者负载均衡和性能有重要影响。</p>
            <ul>
                <li><strong>过小的预取值</strong>：降低吞吐量，因为消息传递速度受限</li>
                <li><strong>过大的预取值</strong>：可能导致某些消费者过载，而其他消费者空闲</li>
                <li><strong>合适的预取值</strong>：根据消费者处理能力和消息处理时间决定</li>
            </ul>

            <h3>15.2 设置预取计数</h3>
            <p>使用原生 API 设置预取计数：</p>
            <pre><code>// 每次只预取一条消息
int prefetchCount = 1;
channel.basicQos(prefetchCount);

// 也可以设置全局模式
boolean global = true; // 适用于通道上的所有消费者
channel.basicQos(prefetchCount, global);</code></pre>

            <h3>15.3 在 Spring AMQP 中设置预取</h3>
            <pre><code>@Bean
public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
        ConnectionFactory connectionFactory) {
        
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);
    
    // 设置预取计数
    factory.setPrefetchCount(10);
    
    return factory;
}

// 或者在应用配置中设置
// application.properties
spring.rabbitmq.listener.simple.prefetch=10</code></pre>

            <h3>15.4 负载均衡考虑</h3>
            <p>实现有效的负载均衡：</p>
            <ol>
                <li><strong>根据消费者能力设置预取</strong>：处理能力强的消费者可以设置更高的预取值</li>
                <li><strong>考虑消息处理时间</strong>：处理时间长的消息应该设置较小的预取值</li>
                <li><strong>动态调整</strong>：根据系统负载情况动态调整预取值</li>
                <li><strong>使用手动确认</strong>：结合手动确认模式更精确地控制消息流</li>
            </ol>

            <h3>15.5 并发消费者</h3>
            <p>在 Spring AMQP 中配置并发消费者：</p>
            <pre><code>@Bean
public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
        ConnectionFactory connectionFactory) {
        
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);
    
    // 设置并发消费者数量
    factory.setConcurrentConsumers(5); // 初始并发消费者数
    factory.setMaxConcurrentConsumers(10); // 最大并发消费者数
    
    return factory;
}

// 或者在应用配置中设置
// application.properties
spring.rabbitmq.listener.simple.concurrency=5
spring.rabbitmq.listener.simple.max-concurrency=10</code></pre>

            <div class="tip">
                <div class="tip-title">性能调优</div>
                <p>在调整预取计数和并发消费者时，建议从较小的值开始，然后根据实际负载和性能指标逐步调整。监控系统的消息吞吐量、处理延迟和资源使用情况，找到最佳配置。</p>
            </div>
        </section>

        <a href="../index.html" class="back-to-home">返回首页</a>
    </main>
</body>
</html> 