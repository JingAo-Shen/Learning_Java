<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>软件测试教程 - Java 学习教程</title>
    <style>
        :root {
            --primary-color: #6DB33F;
            --secondary-color: #5A9E2F;
            --background-color: #f5f5f5;
            --text-color: #333;
            --code-background: #f1f1f1;
            --note-background: #e8f5e9;
            --note-border: #4CAF50;
            --warning-background: #FFF8E1;
            --warning-border: #FFC107;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        header {
            margin-bottom: 30px;
            text-align: center;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 20px;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        h2 {
            color: var(--primary-color);
            margin: 30px 0 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }

        h3 {
            margin: 25px 0 15px;
        }

        p {
            margin-bottom: 15px;
        }

        ul, ol {
            margin: 15px 0;
            padding-left: 25px;
        }

        li {
            margin-bottom: 8px;
        }

        code {
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            background-color: var(--code-background);
            padding: 2px 4px;
            border-radius: 3px;
        }

        pre {
            background-color: var(--code-background);
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }

        .note {
            background-color: var(--note-background);
            border-left: 4px solid var(--note-border);
            padding: 15px;
            margin: 20px 0;
            border-radius: 3px;
        }

        .warning {
            background-color: var(--warning-background);
            border-left: 4px solid var(--warning-border);
            padding: 15px;
            margin: 20px 0;
            border-radius: 3px;
        }

        img {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        table, th, td {
            border: 1px solid #ddd;
        }

        th, td {
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        .back-to-home {
            display: inline-block;
            margin-top: 30px;
            padding: 10px 15px;
            background-color: var(--primary-color);
            color: white;
            text-decoration: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .back-to-home:hover {
            background-color: var(--secondary-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>软件测试教程</h1>
            <p>开发人员自测指南</p>
        </header>

        <h2>1. 软件测试基础</h2>
        <p>软件测试是验证和确认软件产品质量的过程。作为开发人员，为自己的代码编写测试是提高代码质量、减少错误和简化维护的关键步骤。</p>
        
        <h3>1.1 为什么开发人员需要测试自己的代码</h3>
        <ul>
            <li><strong>早期发现问题</strong>：在代码提交前发现并修复缺陷，减少返工</li>
            <li><strong>提高代码质量</strong>：通过严格测试确保代码更可靠、更健壮</li>
            <li><strong>文档化代码行为</strong>：测试用例是代码预期行为的活文档</li>
            <li><strong>简化重构</strong>：有测试保障的代码更容易进行重构和优化</li>
            <li><strong>构建信心</strong>：为代码变更提供安全网，增强修改的信心</li>
        </ul>

        <h3>1.2 测试的分类</h3>
        <p>作为开发人员，您主要关注以下几类测试：</p>
        <ul>
            <li><strong>单元测试</strong>：测试单个函数、方法或类的最小代码单元</li>
            <li><strong>集成测试</strong>：测试多个组件一起工作的情况</li>
            <li><strong>功能测试</strong>：测试完整的功能或用户场景</li>
            <li><strong>性能测试</strong>：验证系统在预期负载下的表现</li>
        </ul>

        <h2>2. 单元测试</h2>
        
        <h3>2.1 单元测试的特点</h3>
        <ul>
            <li><strong>快速</strong>：单元测试应该执行迅速，便于频繁运行</li>
            <li><strong>独立</strong>：每个测试应该独立运行，不依赖其他测试</li>
            <li><strong>可重复</strong>：每次运行应产生相同的结果</li>
            <li><strong>自验证</strong>：测试应该自动判断通过或失败，无需人工解释</li>
            <li><strong>及时</strong>：最好在编写代码的同时或之前编写测试</li>
        </ul>
        
        <h3>2.2 使用 JUnit 编写 Java 单元测试</h3>
        <p>JUnit 是 Java 开发中最常用的单元测试框架。下面是一个简单的例子：</p>
        
        <pre><code>// 被测试的类
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public int subtract(int a, int b) {
        return a - b;
    }
}

// 测试类
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class CalculatorTest {
    
    @Test
    public void testAdd() {
        Calculator calculator = new Calculator();
        assertEquals(5, calculator.add(2, 3), "2 + 3 should equal 5");
    }
    
    @Test
    public void testSubtract() {
        Calculator calculator = new Calculator();
        assertEquals(1, calculator.subtract(3, 2), "3 - 2 should equal 1");
    }
}</code></pre>

        <h3>2.3 测试覆盖率</h3>
        <p>测试覆盖率是衡量代码被测试的程度。常见的覆盖率指标包括：</p>
        <ul>
            <li><strong>行覆盖率</strong>：测试执行的代码行百分比</li>
            <li><strong>分支覆盖率</strong>：测试执行的代码分支百分比</li>
            <li><strong>方法覆盖率</strong>：测试执行的方法百分比</li>
        </ul>
        <p>对于关键代码，建议达到较高的测试覆盖率（如 70-80%），但覆盖率不应该成为唯一目标，测试质量更为重要。</p>

        <h2>3. 测试驱动开发 (TDD)</h2>
        <p>测试驱动开发是一种开发方法，遵循"先测试，后编码"的原则：</p>
        <ol>
            <li><strong>编写测试</strong>：首先编写一个测试用例，描述预期的功能</li>
            <li><strong>运行测试</strong>：此时测试会失败，因为功能尚未实现</li>
            <li><strong>编写代码</strong>：实现功能，使测试通过</li>
            <li><strong>重构</strong>：在测试通过的基础上，优化代码结构</li>
            <li><strong>重复</strong>：继续下一个功能</li>
        </ol>

        <div class="note">
            <p><strong>提示</strong>：TDD 可能最初感觉费时，但随着熟练度提高，它能帮助您编写更高质量、更有针对性的代码。</p>
        </div>

        <h2>4. 模拟与存根</h2>
        
        <h3>4.1 什么是模拟对象</h3>
        <p>模拟对象（Mocks）是模仿依赖项行为的对象，用于隔离被测试的代码。例如，测试依赖数据库的代码时，可以模拟数据库响应，避免实际数据库操作。</p>

        <h3>4.2 使用 Mockito 创建模拟</h3>
        <p>Mockito 是 Java 中流行的模拟框架：</p>
        
        <pre><code>import org.junit.jupiter.api.Test;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class UserServiceTest {

    @Test
    public void testGetUserName() {
        // 创建模拟对象
        UserRepository mockRepository = mock(UserRepository.class);
        // 设置模拟行为
        when(mockRepository.findById(1L)).thenReturn(new User(1L, "张三"));
        
        // 使用模拟对象
        UserService userService = new UserService(mockRepository);
        String name = userService.getUserName(1L);
        
        // 验证结果
        assertEquals("张三", name);
        // 验证交互
        verify(mockRepository).findById(1L);
    }
}</code></pre>

        <h2>5. 集成测试</h2>
        
        <h3>5.1 集成测试的目的</h3>
        <p>集成测试验证多个组件一起工作的情况，捕获单元测试中可能遗漏的交互问题。</p>
        
        <h3>5.2 Spring Boot 的集成测试</h3>
        <p>使用 Spring Boot 的 <code>@SpringBootTest</code> 注解进行集成测试：</p>
        
        <pre><code>@SpringBootTest
public class UserControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;
    
    @Test
    public void testGetUser() throws Exception {
        mockMvc.perform(get("/api/users/1"))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.name").value("张三"));
    }
}</code></pre>

        <h2>6. 测试 Web 应用</h2>
        
        <h3>6.1 前端测试</h3>
        <p>对于前端代码，可以使用以下工具：</p>
        <ul>
            <li><strong>Jest</strong>：JavaScript 测试框架，适用于 React 应用</li>
            <li><strong>Cypress</strong>：端到端测试工具，模拟用户与应用的交互</li>
        </ul>

        <h3>6.2 API 测试</h3>
        <p>使用 Postman 或 REST Assured 测试 REST API：</p>
        
        <pre><code>@Test
public void testGetUser() {
    given()
        .contentType(ContentType.JSON)
    .when()
        .get("/api/users/1")
    .then()
        .statusCode(200)
        .body("name", equalTo("张三"));
}</code></pre>

        <h2>7. 常见的测试坏味道</h2>
        <p>以下是编写测试时应避免的常见问题：</p>
        <ul>
            <li><strong>测试代码重复</strong>：使用 @Before 和 @After 设置和清理公共代码</li>
            <li><strong>测试相互依赖</strong>：确保测试可独立运行</li>
            <li><strong>脆弱的测试</strong>：避免测试依赖于实现细节</li>
            <li><strong>过度复杂的测试</strong>：保持测试简单明了</li>
            <li><strong>忽略测试失败</strong>：测试失败应及时修复</li>
        </ul>

        <h2>8. 测试最佳实践</h2>
        
        <h3>8.1 命名规范</h3>
        <p>良好的测试方法命名有助于理解测试的目的：</p>
        <ul>
            <li><strong>方法名描述场景</strong>：如 <code>testUserLoginWithCorrectCredentials</code></li>
            <li><strong>遵循模式</strong>：如 <code>test[方法名]_[条件]_[预期结果]</code></li>
        </ul>
        
        <h3>8.2 测试组织结构</h3>
        <p>组织测试的常见模式是 AAA（Arrange-Act-Assert）：</p>
        <ul>
            <li><strong>Arrange</strong>：设置测试环境和数据</li>
            <li><strong>Act</strong>：执行被测试的方法</li>
            <li><strong>Assert</strong>：验证结果符合预期</li>
        </ul>
        
        <pre><code>@Test
public void testAddItem_ItemInStock_ReturnsTrue() {
    // Arrange
    ShoppingCart cart = new ShoppingCart();
    Product product = new Product("手机", 100, true);
    
    // Act
    boolean result = cart.addItem(product, 1);
    
    // Assert
    assertTrue(result);
    assertEquals(1, cart.getItemCount());
}</code></pre>

        <h3>8.3 边界值测试</h3>
        <p>测试边界条件和极端情况，如空值、最小值、最大值和边界值：</p>
        
        <pre><code>@Test
public void testCalculateDiscount_ZeroAmount_ReturnsZero() {
    assertEquals(0, discountService.calculateDiscount(0));
}

@Test
public void testCalculateDiscount_NegativeAmount_ThrowsException() {
    assertThrows(IllegalArgumentException.class, 
                 () -> discountService.calculateDiscount(-10));
}</code></pre>

        <h2>9. 持续集成中的测试</h2>
        <p>将测试集成到 CI/CD 流程中，确保每次代码更改都运行测试：</p>
        <ul>
            <li>在 Jenkins、GitLab CI 或 GitHub Actions 中配置测试作业</li>
            <li>设置测试失败时阻止合并或部署</li>
            <li>生成测试报告和覆盖率报告</li>
        </ul>

        <h2>10. 总结</h2>
        <p>有效的测试是开发高质量软件的关键组成部分。作为开发人员，掌握测试技能可以：</p>
        <ul>
            <li>提高代码质量和可靠性</li>
            <li>减少生产环境中的缺陷</li>
            <li>增强代码更改的信心</li>
            <li>提供代码行为的文档</li>
        </ul>
        <p>从编写简单的单元测试开始，逐步扩展到更复杂的测试类型，将测试作为开发流程的常规部分，而不是事后的活动。</p>
        
        <div class="note">
            <p><strong>记住</strong>：好的测试不仅是关于覆盖率，更是关于测试的质量和有效性。优先测试核心功能和业务逻辑。</p>
        </div>
        
        <a href="../index.html" class="back-to-home">返回首页</a>
    </div>
</body>
</html> 