<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket 学习教程</title>
    <style>
        :root {
            --primary-color: #4A86E8;
            --secondary-color: #3D6CB3;
            --background-color: #f5f5f5;
            --text-color: #333;
            --code-background: #f0f0f0;
            --link-color: #0366d6;
            --border-color: #ddd;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 2.5rem;
        }

        h2 {
            color: var(--primary-color);
            margin: 30px 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            font-size: 1.8rem;
        }

        h3 {
            margin: 25px 0 15px 0;
            font-size: 1.4rem;
        }

        h4 {
            margin: 20px 0 10px 0;
            font-size: 1.2rem;
        }

        p {
            margin-bottom: 15px;
        }

        ul, ol {
            margin: 15px 0;
            padding-left: 25px;
        }

        li {
            margin-bottom: 10px;
        }

        code {
            background-color: var(--code-background);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            font-size: 0.9em;
        }

        pre {
            background-color: var(--code-background);
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .note {
            background-color: #e8f4f8;
            border-left: 4px solid #5bc0de;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }

        .warning {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }

        .tip {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }

        .practice {
            background-color: #e2e3e5;
            border-left: 4px solid #6c757d;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }

        img {
            max-width: 100%;
            height: auto;
            margin: 15px 0;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        table, th, td {
            border: 1px solid var(--border-color);
        }

        th, td {
            padding: 10px;
            text-align: left;
        }

        th {
            background-color: #f8f9fa;
        }

        .toc {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }

        .toc ul {
            list-style-type: none;
        }

        .toc ul ul {
            padding-left: 20px;
        }

        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            color: #666;
            font-size: 0.9rem;
        }

        .diagram {
            text-align: center;
            margin: 20px 0;
        }

        .code-comparison {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 15px 0;
        }

        .code-column {
            flex: 1;
            min-width: 300px;
        }

        .protocol-comparison {
            width: 100%;
            overflow-x: auto;
        }

        .reflection-questions {
            background-color: #e8f4ff;
            border-left: 4px solid #4A86E8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .code-comparison {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>WebSocket 学习教程</h1>
            <p>实时网络通信技术详解与实战</p>
        </header>

        <div class="toc">
            <h3>目录</h3>
            <ul>
                <li><a href="#introduction">1. WebSocket 简介</a></li>
                <li><a href="#comparison">2. WebSocket 与 HTTP 对比</a></li>
                <li><a href="#websocket-api">3. WebSocket API</a></li>
                <li><a href="#client">4. WebSocket 客户端实现</a></li>
                <li><a href="#server">5. WebSocket 服务端实现</a></li>
                <li><a href="#spring">6. Spring Boot WebSocket</a></li>
                <li><a href="#security">7. WebSocket 安全</a></li>
                <li><a href="#best-practices">8. 最佳实践</a></li>
                <li><a href="#applications">9. 实际应用场景</a></li>
                <li><a href="#troubleshooting">10. 常见问题与解决方案</a></li>
                <li><a href="#websocket-libraries">11. WebSocket 库与框架</a></li>
            </ul>
        </div>

        <section id="introduction">
            <h2>1. WebSocket 简介</h2>

            <div class="reflection-questions">
                <h4>思考问题</h4>
                <ol>
                    <li>传统的 HTTP 通信在实现实时应用时有哪些局限性？</li>
                    <li>为什么现代 Web 应用需要双向通信能力？</li>
                    <li>你能想象哪些场景需要服务器主动向客户端推送数据？</li>
                    <li>在实现实时通信时，长轮询和服务器发送事件(SSE)与 WebSocket 相比有什么缺点？</li>
                    <li>WebSocket 如何影响应用架构和扩展性设计？</li>
                </ol>
                <p><em>在学习本章内容前，请思考这些问题。这将帮助你更好地理解 WebSocket 技术的价值和应用场景。</em></p>
            </div>

            <h3>1.1 什么是 WebSocket</h3>
            <p>WebSocket 是一种网络通信协议，提供全双工通信通道，使服务器和客户端之间能够在单个 TCP 连接上进行双向实时数据传输。它是 HTML5 规范的一部分，被设计用来克服 HTTP 协议在实时通信方面的局限性。</p>

            <p>与传统的 HTTP 请求-响应模式不同，WebSocket 一旦建立连接，就允许数据在任何时间点、从任何一方发送到另一方，无需重新建立连接，这使得它特别适合需要低延迟、高频率数据交换的应用场景。</p>

            <div class="diagram">
                <img src="https://via.placeholder.com/800x400.png?text=WebSocket+Protocol+Diagram" alt="WebSocket 协议图解">
                <p><em>WebSocket 协议流程图</em></p>
            </div>

            <h3>1.2 WebSocket 的起源与发展</h3>
            <p>WebSocket 协议由 Ian Hickson 起草，并由 IETF 作为 RFC 6455 标准化，同时由 W3C 将 WebSocket API 标准化为 Web IDL 规范的一部分。该协议于 2011 年完成标准化，目的是解决 Web 应用中实时通信的需求，替代当时流行但效率较低的解决方案，如长轮询（Long Polling）和 Comet。</p>

            <p>随着移动互联网、物联网和实时 Web 应用的兴起，WebSocket 技术得到了广泛采用，成为现代 Web 开发中不可或缺的一部分。</p>

            <h3>1.3 WebSocket 的主要特点</h3>
            <ul>
                <li><strong>全双工通信</strong>：服务器和客户端可以同时发送和接收数据，无需等待对方的响应。</li>
                <li><strong>单一 TCP 连接</strong>：WebSocket 通过单一的 TCP 连接传输数据，减少了连接建立的开销。</li>
                <li><strong>低延迟</strong>：由于不需要反复建立连接，WebSocket 提供了更低的通信延迟。</li>
                <li><strong>协议开销小</strong>：相比 HTTP，WebSocket 的头信息更小，减少了数据传输量。</li>
                <li><strong>支持文本和二进制数据</strong>：WebSocket 可以传输文本帧或二进制帧。</li>
                <li><strong>跨域通信</strong>：WebSocket 原生支持跨域通信，不受同源策略限制。</li>
                <li><strong>兼容 HTTP</strong>：WebSocket 使用 HTTP 握手进行连接建立，与现有的 Web 基础设施兼容。</li>
            </ul>

            <div class="note">
                <p>WebSocket URL 使用 <code>ws://</code> 或 <code>wss://</code>（安全 WebSocket）协议标识符，类似于 HTTP 使用 <code>http://</code> 和 <code>https://</code>。</p>
            </div>

            <h3>1.4 WebSocket 的应用场景</h3>
            <p>WebSocket 技术特别适合以下应用场景：</p>
            <ul>
                <li><strong>实时协作工具</strong>：如在线文档编辑、多人游戏、共享白板等。</li>
                <li><strong>即时通讯应用</strong>：聊天室、消息推送、社交媒体实时通知等。</li>
                <li><strong>实时数据更新</strong>：股票行情、体育比分、新闻提醒等需要实时数据推送的场景。</li>
                <li><strong>物联网应用</strong>：设备状态监控、远程控制、传感器数据收集等。</li>
                <li><strong>实时分析和监控</strong>：系统监控仪表盘、日志实时分析、网络流量监控等。</li>
                <li><strong>在线教育</strong>：实时互动课堂、视频会议、远程协作等。</li>
            </ul>

            <div class="practice">
                <h4>实践思考</h4>
                <p>思考一个你熟悉的 Web 应用，它如何从 WebSocket 技术中受益？如果要将该应用改造为使用 WebSocket，主要的架构变化会是什么？</p>
            </div>
        </section>
        
        <section id="comparison">
            <h2>2. WebSocket 与 HTTP 对比</h2>

            <div class="reflection-questions">
                <h4>思考问题</h4>
                <ol>
                    <li>HTTP 协议的无状态特性如何影响实时应用的开发？</li>
                    <li>在不使用 WebSocket 的情况下，如何实现类似的实时通信功能？</li>
                    <li>为什么 WebSocket 比轮询和长轮询更适合高频数据交换？</li>
                    <li>什么样的应用场景下，HTTP 可能比 WebSocket 更合适？</li>
                    <li>WebSocket 和 HTTP/2 推送功能有何异同？</li>
                </ol>
                <p><em>在学习本章内容前，请思考这些问题。这将帮助你理解不同协议的优缺点和适用场景。</em></p>
            </div>

            <h3>2.1 通信模型比较</h3>
            <p>HTTP 和 WebSocket 在通信模型上有根本性的区别：</p>
            
            <div class="comparison-table">
                <table>
                    <thead>
                        <tr>
                            <th>特性</th>
                            <th>HTTP</th>
                            <th>WebSocket</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>通信方式</td>
                            <td>单向（请求-响应）</td>
                            <td>双向（全双工）</td>
                        </tr>
                        <tr>
                            <td>连接特性</td>
                            <td>短连接（非持久）或多请求持久连接</td>
                            <td>长连接（持久）</td>
                        </tr>
                        <tr>
                            <td>状态</td>
                            <td>无状态</td>
                            <td>有状态</td>
                        </tr>
                        <tr>
                            <td>头部开销</td>
                            <td>每次请求都有完整的头部</td>
                            <td>仅在建立连接时有完整头部，之后很小</td>
                        </tr>
                        <tr>
                            <td>实时性</td>
                            <td>依赖客户端请求</td>
                            <td>服务器可主动推送</td>
                        </tr>
                        <tr>
                            <td>交互模式</td>
                            <td>同步</td>
                            <td>异步</td>
                        </tr>
                        <tr>
                            <td>适用场景</td>
                            <td>常规网页、RESTful API、数据提交</td>
                            <td>聊天、游戏、实时监控、协作工具</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="diagram">
                <img src="https://via.placeholder.com/800x400.png?text=HTTP+vs+WebSocket+Communication+Model" alt="HTTP vs WebSocket 通信模型对比">
                <p><em>HTTP 与 WebSocket 通信模型对比图</em></p>
            </div>

            <h3>2.2 HTTP 实时通信解决方案</h3>
            <p>在 WebSocket 出现之前，开发者使用多种技术在 HTTP 上模拟实时通信：</p>

            <h4>2.2.1 轮询（Polling）</h4>
            <p>客户端定期向服务器发送请求，检查是否有新数据。这种方法简单但效率低下，会产生大量无效请求和服务器负载。</p>
            
            <pre><code class="javascript">// 简单的轮询示例
function poll() {
    fetch('/api/updates')
        .then(response => response.json())
        .then(data => {
            if(data.hasUpdates) {
                processUpdates(data);
            }
            // 5秒后再次轮询
            setTimeout(poll, 5000);
        })
        .catch(error => console.error('轮询出错:', error));
}

poll(); // 开始轮询
</code></pre>

            <h4>2.2.2 长轮询（Long Polling）</h4>
            <p>客户端发送请求后，服务器保持连接打开，直到有新数据或超时。这减少了轮询的频率，但仍有连接开销。</p>
            
            <pre><code class="javascript">// 长轮询示例
function longPoll() {
    fetch('/api/updates?timeout=30000')
        .then(response => response.json())
        .then(data => {
            processUpdates(data);
            // 立即发起新的长轮询请求
            longPoll();
        })
        .catch(error => {
            console.error('长轮询出错:', error);
            // 出错时稍等后重试
            setTimeout(longPoll, 1000);
        });
}

longPoll(); // 开始长轮询
</code></pre>

            <h4>2.2.3 服务器发送事件（Server-Sent Events, SSE）</h4>
            <p>允许服务器通过单个 HTTP 连接向客户端推送数据。这是单向的（只能服务器到客户端），但比轮询更高效。</p>
            
            <pre><code class="javascript">// SSE 示例
const eventSource = new EventSource('/api/events');

eventSource.onmessage = function(event) {
    const data = JSON.parse(event.data);
    processUpdates(data);
};

eventSource.onerror = function(error) {
    console.error('SSE 出错:', error);
    eventSource.close();
};
</code></pre>

            <h3>2.3 性能与资源使用对比</h3>
            <p>WebSocket 相比 HTTP 实时通信解决方案有显著的性能优势：</p>
            
            <div class="comparison-table">
                <table>
                    <thead>
                        <tr>
                            <th>性能指标</th>
                            <th>轮询</th>
                            <th>长轮询</th>
                            <th>SSE</th>
                            <th>WebSocket</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>连接开销</td>
                            <td>高（频繁连接）</td>
                            <td>中（较少连接）</td>
                            <td>低（单一连接）</td>
                            <td>低（单一连接）</td>
                        </tr>
                        <tr>
                            <td>头部开销</td>
                            <td>高</td>
                            <td>高</td>
                            <td>中（仅首次高）</td>
                            <td>低（仅首次高）</td>
                        </tr>
                        <tr>
                            <td>数据实时性</td>
                            <td>低（受轮询间隔限制）</td>
                            <td>中（有延迟）</td>
                            <td>高（服务器推送）</td>
                            <td>高（即时双向）</td>
                        </tr>
                        <tr>
                            <td>服务器资源消耗</td>
                            <td>高</td>
                            <td>中</td>
                            <td>低-中</td>
                            <td>低</td>
                        </tr>
                        <tr>
                            <td>网络带宽使用</td>
                            <td>高</td>
                            <td>中</td>
                            <td>低-中</td>
                            <td>低</td>
                        </tr>
                        <tr>
                            <td>通信方向</td>
                            <td>客户端到服务器</td>
                            <td>客户端到服务器</td>
                            <td>服务器到客户端</td>
                            <td>双向</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="note">
                <p>在高频数据交换（如在线游戏、协作编辑）或需要低延迟的场景中，WebSocket 的性能优势尤为明显。一项研究表明，在高并发环境下，WebSocket 可以比轮询减少高达 90% 的服务器负载。</p>
            </div>

            <h3>2.4 何时选择 WebSocket 或 HTTP</h3>
            <p>选择合适的协议应基于应用需求：</p>
            
            <h4>适合使用 WebSocket 的场景：</h4>
            <ul>
                <li>需要低延迟的实时双向通信</li>
                <li>服务器需要主动向客户端推送数据</li>
                <li>需要保持连接状态的应用</li>
                <li>高频数据交换（如股票行情、游戏状态更新）</li>
                <li>多客户端之间需要近实时同步的协作应用</li>
            </ul>
            
            <h4>适合使用 HTTP 的场景：</h4>
            <ul>
                <li>简单的请求-响应交互</li>
                <li>不需要实时更新的静态内容</li>
                <li>RESTful API 设计的服务</li>
                <li>低频率数据更新的应用</li>
                <li>无需服务器主动推送的单向数据流</li>
                <li>需要利用 HTTP 缓存机制的内容</li>
            </ul>

            <div class="practice">
                <h4>实践思考</h4>
                <p>分析一个现有的使用长轮询实现"实时"功能的应用，估算如果改用 WebSocket 协议，会节省多少请求次数和带宽。考虑用户数量、更新频率和每次请求的数据量等因素。</p>
            </div>
        </section>
        
        <section id="websocket-api">
            <h2>3. WebSocket API</h2>

            <div class="reflection-questions">
                <h4>思考问题</h4>
                <ol>
                    <li>浏览器原生 WebSocket API 提供了哪些基本功能？</li>
                    <li>WebSocket 连接的各个生命周期事件分别代表什么状态？</li>
                    <li>如何判断一个 WebSocket 连接是否仍然活跃？</li>
                    <li>WebSocket 协议如何处理不同类型的数据（文本、二进制）？</li>
                    <li>在开发中，如何优雅地处理 WebSocket 重连逻辑？</li>
                </ol>
                <p><em>请思考这些问题，帮助你理解 WebSocket API 的核心概念和使用模式。</em></p>
            </div>

            <h3>3.1 WebSocket 协议基础</h3>
            <p>WebSocket 协议是一个独立的 TCP 协议，以 HTTP 握手开始，但随后转换为自己的协议。</p>
            
            <h4>3.1.1 WebSocket URL</h4>
            <p>WebSocket 使用特殊的 URL 方案：</p>
            <ul>
                <li><code>ws://</code> - 非加密连接（等同于 http://）</li>
                <li><code>wss://</code> - 加密连接（等同于 https://）</li>
            </ul>
            <p>示例：<code>wss://echo.websocket.org</code></p>

            <div class="warning">
                <p>在生产环境中，始终使用 <code>wss://</code> 协议以确保数据传输安全。非加密的 <code>ws://</code> 连接容易受到中间人攻击。</p>
            </div>

            <h4>3.1.2 WebSocket 握手</h4>
            <p>WebSocket 连接始于 HTTP 握手，客户端发送特殊的升级请求，服务器接受后协议切换为 WebSocket：</p>
            
            <pre><code class="http">// 客户端请求
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13

// 服务器响应
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat</code></pre>

            <h3>3.2 浏览器 WebSocket API</h3>
            <p>Web 浏览器提供了简洁的原生 WebSocket API，用于创建和管理 WebSocket 连接。</p>
            
            <h4>3.2.1 创建 WebSocket 连接</h4>
            <pre><code class="javascript">// 创建一个新的 WebSocket 连接
const socket = new WebSocket('wss://example.com/socketserver');

// 可选：指定协议
const chatSocket = new WebSocket('wss://example.com/chat', ['json', 'xml']);</code></pre>

            <h4>3.2.2 WebSocket 事件</h4>
            <p>WebSocket API 提供了四个主要事件用于处理连接的生命周期和消息传递：</p>
            
            <pre><code class="javascript">// 连接建立时触发
socket.onopen = function(event) {
    console.log('WebSocket 连接已建立');
    // 可以开始发送消息
    socket.send('Hello Server!');
};

// 收到消息时触发
socket.onmessage = function(event) {
    console.log('收到消息: ' + event.data);
    // 处理收到的消息
};

// 连接关闭时触发
socket.onclose = function(event) {
    console.log('WebSocket 连接已关闭');
    // event.code: 关闭码
    // event.reason: 关闭原因
    // event.wasClean: 是否是干净关闭
};

// 发生错误时触发
socket.onerror = function(error) {
    console.error('WebSocket 错误: ', error);
};</code></pre>

            <p>也可以使用 EventListener 模式：</p>
            
            <pre><code class="javascript">socket.addEventListener('open', function(event) {
    console.log('WebSocket 连接已建立');
});

socket.addEventListener('message', function(event) {
    console.log('收到消息: ' + event.data);
});</code></pre>

            <h4>3.2.3 发送数据</h4>
            <p>WebSocket API 支持发送文本和二进制数据：</p>
            
            <pre><code class="javascript">// 发送文本数据
socket.send('Hello Server!');

// 发送 JSON 数据
const data = {
    type: 'chat',
    message: 'Hello everyone!',
    timestamp: Date.now()
};
socket.send(JSON.stringify(data));

// 发送二进制数据
const binaryData = new Uint8Array([0, 1, 2, 3]);
socket.send(binaryData.buffer);</code></pre>

            <h4>3.2.4 关闭连接</h4>
            <p>WebSocket 连接可以由客户端或服务器关闭：</p>
            
            <pre><code class="javascript">// 正常关闭连接
socket.close();

// 带关闭码和原因的关闭
socket.close(1000, "操作完成");

// 常见关闭码：
// 1000 - 正常关闭
// 1001 - 离开（如页面关闭）
// 1002 - 协议错误
// 1003 - 无法接受的数据类型
// 1008 - 违反策略
// 1011 - 服务器错误</code></pre>

            <h3>3.3 WebSocket 连接状态</h3>
            <p>WebSocket 对象提供了 <code>readyState</code> 属性，用于检查连接的当前状态：</p>
            
            <pre><code class="javascript">// 检查连接状态
switch(socket.readyState) {
    case WebSocket.CONNECTING: // 0
        console.log('连接中...');
        break;
    case WebSocket.OPEN: // 1
        console.log('连接已打开');
        // 只有在连接打开时才能发送消息
        socket.send('数据');
        break;
    case WebSocket.CLOSING: // 2
        console.log('连接正在关闭');
        break;
    case WebSocket.CLOSED: // 3
        console.log('连接已关闭或无法打开');
        break;
}</code></pre>

            <div class="tip">
                <p>在发送消息前，总是检查 <code>readyState</code> 是否为 <code>WebSocket.OPEN</code>，以避免在连接未建立或已关闭时尝试发送数据而导致错误。</p>
            </div>

            <h3>3.4 高级功能和最佳实践</h3>

            <h4>3.4.1 心跳机制</h4>
            <p>为了保持连接活跃并检测连接断开，可以实现心跳机制：</p>
            
            <pre><code class="javascript">// 实现简单的心跳机制
function heartbeat() {
    if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({type: 'ping'}));
    }
}

// 每30秒发送一次心跳
const heartbeatInterval = setInterval(heartbeat, 30000);

// 收到服务器响应重置计时器
let timeoutId = null;
socket.onmessage = function(event) {
    // 处理消息...
    
    // 清除上一个超时计时器
    if (timeoutId) {
        clearTimeout(timeoutId);
    }
    
    // 设置新的超时计时器
    timeoutId = setTimeout(() => {
        console.log('连接似乎已断开，尝试重连');
        reconnect();
    }, 35000); // 稍长于心跳间隔
};</code></pre>

            <h4>3.4.2 自动重连</h4>
            <p>实现可靠的自动重连机制，确保连接中断时能自动恢复：</p>
            
            <pre><code class="javascript">// 更复杂的 WebSocket 包装器，包含自动重连功能
class ReconnectingWebSocket {
    constructor(url, protocols) {
        this.url = url;
        this.protocols = protocols;
        this.socket = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectInterval = 1000; // 起始为1秒
        this.maxReconnectInterval = 30000; // 最大30秒
        this.callbacks = {
            open: [],
            message: [],
            close: [],
            error: []
        };
        
        this.connect();
    }
    
    connect() {
        this.socket = new WebSocket(this.url, this.protocols);
        
        this.socket.onopen = (event) => {
            console.log('WebSocket 连接已建立');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.callbacks.open.forEach(callback => callback(event));
        };
        
        this.socket.onmessage = (event) => {
            this.callbacks.message.forEach(callback => callback(event));
        };
        
        this.socket.onclose = (event) => {
            this.isConnected = false;
            this.callbacks.close.forEach(callback => callback(event));
            
            if (!event.wasClean) {
                this.reconnect();
            }
        };
        
        this.socket.onerror = (event) => {
            this.callbacks.error.forEach(callback => callback(event));
        };
    }
    
    reconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.log('达到最大重连次数');
            return;
        }
        
        this.reconnectAttempts++;
        const timeout = Math.min(
            this.reconnectInterval * Math.pow(1.5, this.reconnectAttempts),
            this.maxReconnectInterval
        );
        
        console.log(`尝试在 ${timeout}ms 后重连...`);
        setTimeout(() => this.connect(), timeout);
    }
    
    addEventListener(type, callback) {
        if (this.callbacks[type]) {
            this.callbacks[type].push(callback);
        }
    }
    
    send(data) {
        if (this.isConnected) {
            this.socket.send(data);
            return true;
        }
        return false;
    }
    
    close(code, reason) {
        if (this.socket) {
            this.socket.close(code, reason);
        }
    }
}

// 使用示例
const ws = new ReconnectingWebSocket('wss://example.com/socket');
ws.addEventListener('message', function(event) {
    console.log('收到消息:', event.data);
});</code></pre>

            <div class="practice">
                <h4>实践练习</h4>
                <p>使用原生 WebSocket API 创建一个简单的聊天应用，包含以下功能：</p>
                <ol>
                    <li>连接到公共 WebSocket 服务器（如 wss://echo.websocket.org）</li>
                    <li>发送和接收文本消息</li>
                    <li>实现基本的心跳检测功能</li>
                    <li>实现简单的重连机制</li>
                    <li>显示连接状态</li>
                </ol>
                <p>这个练习将帮助你理解 WebSocket API 的基本操作和管理连接生命周期的实践技巧。</p>
            </div>
        </section>
        
        <section id="websocket-libraries">
            <h2>4. WebSocket 库与框架</h2>

            <div class="reflection-questions">
                <h4>思考问题</h4>
                <ol>
                    <li>在什么情况下应该使用第三方 WebSocket 库而非原生 API？</li>
                    <li>Socket.IO 相比原生 WebSocket 提供了哪些额外功能？</li>
                    <li>企业级应用中，为何 STOMP 协议经常与 WebSocket 结合使用？</li>
                    <li>如何在现有框架（如 React、Vue、Angular）中集成 WebSocket 功能？</li>
                    <li>如何评估一个 WebSocket 库的性能和可靠性？</li>
                </ol>
                <p><em>思考这些问题，帮助你选择适合项目需求的 WebSocket 解决方案。</em></p>
            </div>

            <h3>4.1 客户端 WebSocket 库</h3>
            <p>虽然浏览器原生 WebSocket API 功能完善，但第三方库可以提供更多高级特性和便利性：</p>

            <h4>4.1.1 Socket.IO 客户端</h4>
            <p>Socket.IO 是最流行的 WebSocket 库之一，提供了丰富的功能和优雅的回退机制：</p>
            
            <pre><code class="javascript">// 安装
// npm install socket.io-client

// 使用
import { io } from "socket.io-client";

const socket = io("https://example.com", {
    reconnectionDelayMax: 10000,
    auth: {
        token: "user-token"
    }
});

// 事件处理
socket.on("connect", () => {
    console.log("已连接，ID:", socket.id);
});

// 发送事件
socket.emit("chat message", { text: "Hello!" });

// 接收事件
socket.on("chat message", (data) => {
    console.log("收到消息:", data);
});

// 命名空间和房间
const adminSocket = io("https://example.com/admin");
socket.emit("join", "room1");

// 断开连接
socket.disconnect();</code></pre>

            <h4>4.1.2 SockJS</h4>
            <p>SockJS 提供了一个类似 WebSocket 的 API，但在不支持 WebSocket 的环境中具有多种回退选项：</p>
            
            <pre><code class="javascript">// 安装
// npm install sockjs-client

// 使用
import SockJS from 'sockjs-client';

const sock = new SockJS('https://example.com/echo');

sock.onopen = function() {
    console.log('连接已打开');
    sock.send('test');
};

sock.onmessage = function(e) {
    console.log('收到消息:', e.data);
};

sock.onclose = function() {
    console.log('连接已关闭');
};</code></pre>

            <div class="comparison">
                <h4>Socket.IO 与 SockJS 对比</h4>
                <table>
                    <tr>
                        <th>特性</th>
                        <th>Socket.IO</th>
                        <th>SockJS</th>
                    </tr>
                    <tr>
                        <td>基本协议</td>
                        <td>自定义协议（基于 WebSocket）</td>
                        <td>WebSocket API 兼容</td>
                    </tr>
                    <tr>
                        <td>回退机制</td>
                        <td>多种回退（长轮询、AJAX等）</td>
                        <td>多种回退（XHR流、长轮询等）</td>
                    </tr>
                    <tr>
                        <td>命名空间/房间</td>
                        <td>原生支持</td>
                        <td>不支持（需自行实现）</td>
                    </tr>
                    <tr>
                        <td>自动重连</td>
                        <td>内置</td>
                        <td>需手动实现</td>
                    </tr>
                    <tr>
                        <td>服务器实现</td>
                        <td>需要 Socket.IO 服务器</td>
                        <td>SockJS 服务器（多语言支持）</td>
                    </tr>
                    <tr>
                        <td>生态系统</td>
                        <td>庞大，有丰富的插件</td>
                        <td>多语言支持，与 STOMP 结合良好</td>
                    </tr>
                </table>
            </div>

            <h3>4.2 STOMP 协议</h3>
            <p>STOMP（Simple Text Oriented Messaging Protocol）是一个简单的基于帧的协议，可以在 WebSocket 上实现：</p>
            
            <pre><code class="javascript">// 安装
// npm install @stomp/stompjs

// 使用
import { Client } from '@stomp/stompjs';

const client = new Client({
    brokerURL: 'ws://example.com/ws',
    connectHeaders: {
        login: 'user',
        passcode: 'password'
    },
    debug: function (str) {
        console.log(str);
    },
    reconnectDelay: 5000,
    heartbeatIncoming: 4000,
    heartbeatOutgoing: 4000
});

client.onConnect = function (frame) {
    // 订阅主题
    const subscription = client.subscribe('/topic/messages', function (message) {
        const payload = JSON.parse(message.body);
        console.log('收到消息:', payload);
    });

    // 发送消息到指定目的地
    client.publish({
        destination: '/app/chat',
        body: JSON.stringify({ content: 'Hello, STOMP' }),
        headers: { priority: '9' }
    });
};

client.onStompError = function (frame) {
    console.error('STOMP 错误:', frame.headers['message']);
};

client.activate();</code></pre>

            <div class="tip">
                <p>STOMP 非常适合与 Spring 后端集成，Spring 提供了完整的 STOMP over WebSocket 支持。</p>
            </div>

            <h3>4.3 框架集成</h3>
            <p>现代前端框架提供了便捷的方式集成 WebSocket 功能：</p>

            <h4>4.3.1 React 集成</h4>
            <pre><code class="javascript">// 创建 WebSocket 钩子
import { useState, useEffect, useCallback } from 'react';

function useWebSocket(url) {
    const [socket, setSocket] = useState(null);
    const [isConnected, setIsConnected] = useState(false);
    const [messages, setMessages] = useState([]);

    useEffect(() => {
        // 创建 WebSocket 连接
        const ws = new WebSocket(url);
        
        ws.onopen = () => {
            setIsConnected(true);
        };
        
        ws.onmessage = (event) => {
            setMessages(prev => [...prev, event.data]);
        };
        
        ws.onclose = () => {
            setIsConnected(false);
        };
        
        setSocket(ws);
        
        // 清理函数
        return () => {
            ws.close();
        };
    }, [url]);
    
    // 发送消息方法
    const sendMessage = useCallback((data) => {
        if (socket && isConnected) {
            socket.send(data);
            return true;
        }
        return false;
    }, [socket, isConnected]);
    
    return { isConnected, messages, sendMessage };
}

// 在组件中使用
function ChatComponent() {
    const { isConnected, messages, sendMessage } = useWebSocket('wss://example.com/chat');
    const [inputValue, setInputValue] = useState('');
    
    const handleSubmit = (e) => {
        e.preventDefault();
        if (inputValue && sendMessage(inputValue)) {
            setInputValue('');
        }
    };
    
    return (
        <div>
            <div>{isConnected ? '已连接' : '未连接'}</div>
            <ul>
                {messages.map((msg, index) => (
                    <li key={index}>{msg}</li>
                ))}
            </ul>
            <form onSubmit={handleSubmit}>
                <input
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                />
                <button type="submit">发送</button>
            </form>
        </div>
    );
}</code></pre>

            <h4>4.3.2 Vue 集成</h4>
            <pre><code class="javascript">// Vue 3 WebSocket 组合式 API
import { ref, onMounted, onBeforeUnmount } from 'vue';

export function useWebSocket(url) {
    const socket = ref(null);
    const isConnected = ref(false);
    const messages = ref([]);
    
    const connect = () => {
        socket.value = new WebSocket(url);
        
        socket.value.onopen = () => {
            isConnected.value = true;
        };
        
        socket.value.onmessage = (event) => {
            messages.value.push(event.data);
        };
        
        socket.value.onclose = () => {
            isConnected.value = false;
        };
    };
    
    const sendMessage = (data) => {
        if (socket.value && isConnected.value) {
            socket.value.send(data);
            return true;
        }
        return false;
    };
    
    onMounted(() => {
        connect();
    });
    
    onBeforeUnmount(() => {
        if (socket.value) {
            socket.value.close();
        }
    });
    
    return {
        isConnected,
        messages,
        sendMessage
    };
}

// 在组件中使用
<template>
  <div>
    <div>{{ isConnected ? '已连接' : '未连接' }}</div>
    <ul>
      <li v-for="(msg, index) in messages" :key="index">{{ msg }}</li>
    </ul>
    <form @submit.prevent="sendMsg">
      <input v-model="inputValue" />
      <button type="submit">发送</button>
    </form>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useWebSocket } from './useWebSocket';

const { isConnected, messages, sendMessage } = useWebSocket('wss://example.com/chat');
const inputValue = ref('');

function sendMsg() {
  if (inputValue.value && sendMessage(inputValue.value)) {
    inputValue.value = '';
  }
}
</script></code></pre>

            <h3>4.4 选择合适的解决方案</h3>
            <p>选择 WebSocket 实现方案时，考虑以下因素：</p>
            
            <ul>
                <li><strong>兼容性需求</strong>：是否需要支持旧版浏览器？如果是，选择带回退机制的库</li>
                <li><strong>功能需求</strong>：是否需要房间、命名空间、认证等高级功能</li>
                <li><strong>后端集成</strong>：使用什么后端技术栈？例如，Spring 后端推荐使用 STOMP</li>
                <li><strong>项目规模</strong>：小型项目可能原生 WebSocket 足够，大型项目可能需要更强大的库</li>
                <li><strong>消息模式</strong>：是否需要发布/订阅模式？STOMP 或 Socket.IO 提供良好支持</li>
                <li><strong>学习曲线</strong>：团队对不同技术的熟悉程度</li>
            </ul>

            <div class="decision-tree">
                <h4>WebSocket 库选择决策树</h4>
                <pre>
                                    需要 WebSocket 功能
                                            │
                    ┌────────────────┬──────┴──────┬────────────────┐
                    │                │             │                │
                 简单需求      需要广泛兼容性     企业级应用      与特定框架集成
                    │                │             │                │
              原生 WebSocket      Socket.IO      STOMP       框架特定解决方案
                                     │             │         (React/Vue hooks)
                                     │             │
                                     └─────┬───────┘
                                           │
                                     根据后端技术选择
                                           │
                               ┌───────────┴───────────┐
                               │                       │
                          Node.js 后端             Java/Spring 后端
                               │                       │
                          Socket.IO              STOMP over SockJS
                </pre>
            </div>

            <div class="practice">
                <h4>实践练习</h4>
                <p>对比实现：</p>
                <ol>
                    <li>使用原生 WebSocket API 实现一个简单的聊天应用</li>
                    <li>使用 Socket.IO 实现同样的功能</li>
                    <li>使用 STOMP 实现同样的功能</li>
                    <li>比较三种实现在代码复杂度、功能完整性和扩展性方面的差异</li>
                </ol>
                <p>这个练习将帮助你理解不同 WebSocket 库的优缺点，为实际项目选择最合适的技术。</p>
            </div>
        </section>
        
        <section id="websocket-security">
            <h2>5. WebSocket 安全</h2>

            <div class="reflection-questions">
                <h4>思考问题</h4>
                <ol>
                    <li>WebSocket 连接面临哪些常见的安全威胁？</li>
                    <li>为什么应该使用 WSS 而非 WS 协议？</li>
                    <li>如何验证 WebSocket 连接的身份？</li>
                    <li>WebSocket 消息需要哪些验证措施？</li>
                    <li>如何防止 WebSocket 服务器过载？</li>
                </ol>
                <p><em>思考这些问题，帮助你构建更安全的 WebSocket 应用。</em></p>
            </div>

            <h3>5.1 WebSocket 安全威胁</h3>
            <p>WebSocket 应用面临多种安全威胁，包括：</p>

            <div class="vulnerability">
                <h4>5.1.1 常见 WebSocket 安全漏洞</h4>
                <table>
                    <tr>
                        <th>威胁</th>
                        <th>描述</th>
                        <th>影响</th>
                    </tr>
                    <tr>
                        <td>跨站 WebSocket 劫持</td>
                        <td>攻击者利用恶意网站发起 WebSocket 连接至受害者已授权的站点</td>
                        <td>未经授权访问用户数据，执行未授权操作</td>
                    </tr>
                    <tr>
                        <td>中间人攻击</td>
                        <td>攻击者拦截并可能修改未加密的 WebSocket 通信</td>
                        <td>数据泄露，通信篡改</td>
                    </tr>
                    <tr>
                        <td>拒绝服务攻击</td>
                        <td>通过大量 WebSocket 连接或消息使服务器资源耗尽</td>
                        <td>服务不可用</td>
                    </tr>
                    <tr>
                        <td>WebSocket 劫持</td>
                        <td>未授权第三方接管活跃的 WebSocket 连接</td>
                        <td>会话劫持，数据泄露</td>
                    </tr>
                    <tr>
                        <td>输入验证漏洞</td>
                        <td>未对通过 WebSocket 传输的数据进行适当验证</td>
                        <td>注入攻击，XSS，数据库漏洞</td>
                    </tr>
                </table>
            </div>

            <h3>5.2 WebSocket 安全最佳实践</h3>
            <p>保护 WebSocket 应用需采取多层防御策略：</p>

            <h4>5.2.1 传输安全</h4>
            <pre><code class="javascript">// 始终使用 WSS 而非 WS
const socket = new WebSocket('wss://example.com/socket');</code></pre>
            <p>将 HTTP 升级为 HTTPS，同样将 WS 升级为 WSS：</p>
            <ul>
                <li>WSS 使用 TLS/SSL 加密所有通信</li>
                <li>防止中间人攻击和数据窃听</li>
                <li>提供服务器身份验证</li>
            </ul>
            <div class="warning">
                <p>永远不要在生产环境中使用非加密的 WS 协议，即使是内部应用也应使用 WSS。</p>
            </div>

            <h4>5.2.2 身份验证与授权</h4>
            <p>在建立 WebSocket 连接时验证用户身份：</p>

            <pre><code class="javascript">// 客户端：在握手时包含授权令牌
const token = localStorage.getItem('authToken');
const socket = new WebSocket(`wss://example.com/socket?token=${token}`);

// 或者通过自定义头部（需服务器支持）
fetch('wss://example.com/socket', {
    headers: {
        'Authorization': `Bearer ${token}`
    }
});</code></pre>

            <p>服务器端授权验证（Node.js 示例）：</p>
            <pre><code class="javascript">// 服务器：WebSocket 连接身份验证
const WebSocket = require('ws');
const url = require('url');
const jwt = require('jsonwebtoken');

const wss = new WebSocket.Server({ noServer: true });
const server = http.createServer();

server.on('upgrade', function (request, socket, head) {
    // 从URL查询参数中提取令牌
    const pathname = url.parse(request.url).pathname;
    const query = url.parse(request.url, true).query;
    
    // 验证令牌
    authenticateToken(query.token)
        .then(user => {
            // 存储用户信息，授权成功
            request.user = user;
            wss.handleUpgrade(request, socket, head, function (ws) {
                wss.emit('connection', ws, request);
            });
        })
        .catch(err => {
            // 授权失败，关闭连接
            socket.write('HTTP/1.1 401 Unauthorized\r\n\r\n');
            socket.destroy();
        });
});

// 验证令牌函数
function authenticateToken(token) {
    return new Promise((resolve, reject) => {
        if (!token) return reject('需要令牌');
        
        jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
            if (err) return reject('无效令牌');
            resolve(user);
        });
    });
}</code></pre>

            <div class="tip">
                <p>最佳实践：单独为 WebSocket 连接创建短期令牌，而不是重用主应用的长期令牌。</p>
            </div>

            <h4>5.2.3 消息验证和清理</h4>
            <p>始终验证从客户端接收的 WebSocket 消息：</p>

            <pre><code class="javascript">// 客户端：发送结构化消息
socket.send(JSON.stringify({
    type: 'chat_message',
    content: message,
    timestamp: Date.now()
}));

// 服务器：验证消息结构和内容
wss.on('connection', (ws, request) => {
    const user = request.user; // 从身份验证中
    
    ws.on('message', (message) => {
        try {
            // 解析并验证消息
            const data = JSON.parse(message);
            
            // 检查必要字段
            if (!data.type || !data.content) {
                return sendError(ws, '无效消息格式');
            }
            
            // 验证内容（防止XSS等）
            if (!isValidContent(data.content)) {
                return sendError(ws, '包含不允许的内容');
            }
            
            // 附加已验证的用户信息
            data.userId = user.id;
            data.username = user.username;
            
            // 处理验证后的消息
            handleMessage(data, ws);
        } catch (e) {
            sendError(ws, '无效的JSON');
        }
    });
});

function isValidContent(content) {
    // 实现内容验证逻辑
    // 例如：长度限制、XSS过滤等
    return content.length > 0 && 
           content.length <= 1000 && 
           !/<script|javascript:|on\w+=/i.test(content);
}

function sendError(ws, message) {
    ws.send(JSON.stringify({
        type: 'error',
        message: message
    }));
}</code></pre>

            <h4>5.2.4 速率限制与资源保护</h4>
            <p>防止 WebSocket 服务器过载：</p>

            <pre><code class="javascript">// 服务器端速率限制实现
const clients = new Map(); // 跟踪客户端

wss.on('connection', (ws, request) => {
    const userId = request.user.id;
    
    // 存储客户端信息
    clients.set(ws, {
        userId: userId,
        connectionTime: Date.now(),
        messageCount: 0,
        lastMessageTime: Date.now()
    });
    
    // 设置连接限制（例如2小时后自动断开）
    const connectionTimeout = setTimeout(() => {
        ws.close(1000, '连接超时');
    }, 2 * 60 * 60 * 1000); // 2小时
    
    ws.on('message', (message) => {
        const clientInfo = clients.get(ws);
        const now = Date.now();
        
        // 速率限制：每分钟最多60条消息
        if (clientInfo.messageCount > 60 && 
            (now - clientInfo.lastMessageTime) < 60000) {
            ws.send(JSON.stringify({
                type: 'error',
                message: '消息速率超限，请稍后再试'
            }));
            return;
        }
        
        // 限制消息大小
        if (message.length > 10000) { // 10KB 限制
            ws.send(JSON.stringify({
                type: 'error',
                message: '消息过大'
            }));
            return;
        }
        
        // 更新客户端统计信息
        clientInfo.messageCount++;
        clientInfo.lastMessageTime = now;
        
        // 正常处理消息...
    });
    
    ws.on('close', () => {
        // 清理
        clearTimeout(connectionTimeout);
        clients.delete(ws);
    });
});

// 服务器全局限制
const MAX_CONNECTIONS = 10000;
wss.on('connection', (ws, request) => {
    if (wss.clients.size > MAX_CONNECTIONS) {
        ws.close(1013, '服务器已达最大连接数');
        return;
    }
    // 正常连接处理...
});</code></pre>

            <h4>5.2.5 同源策略与CORS</h4>
            <p>虽然WebSocket不完全受制于同源策略，但仍应实施适当的CORS保护：</p>

            <pre><code class="javascript">// Node.js服务器CORS验证
server.on('upgrade', function (request, socket, head) {
    // 检查源
    const origin = request.headers.origin;
    const allowedOrigins = [
        'https://example.com', 
        'https://subdomain.example.com'
    ];
    
    if (!origin || !allowedOrigins.includes(origin)) {
        socket.write('HTTP/1.1 403 Forbidden\r\n\r\n');
        socket.destroy();
        return;
    }
    
    // 继续处理连接...
});</code></pre>

            <h3>5.3 监控与审计</h3>
            <p>实施 WebSocket 安全监控：</p>
            <ul>
                <li>记录所有连接尝试，包括成功和失败</li>
                <li>记录异常行为（高消息速率、大消息、格式错误的消息）</li>
                <li>实施实时异常检测</li>
                <li>保留连接和消息日志用于事后审计</li>
            </ul>

            <pre><code class="javascript">// 服务器日志记录示例
wss.on('connection', (ws, request) => {
    const ip = request.socket.remoteAddress;
    const userId = request.user ? request.user.id : 'anonymous';
    
    console.log(`连接已建立 - 用户: ${userId}, IP: ${ip}, 时间: ${new Date().toISOString()}`);
    
    ws.on('message', (message) => {
        // 记录消息统计（不记录完整内容以保护隐私）
        console.log(`收到消息 - 用户: ${userId}, 大小: ${message.length}字节, 时间: ${new Date().toISOString()}`);
        
        // 对于可疑消息，记录更多信息
        if (message.length > 5000) {
            console.warn(`大消息警告 - 用户: ${userId}, 大小: ${message.length}字节`);
            // 可以触发安全警报
        }
    });
    
    ws.on('close', (code, reason) => {
        console.log(`连接已关闭 - 用户: ${userId}, 代码: ${code}, 原因: ${reason}, 时间: ${new Date().toISOString()}`);
    });
    
    ws.on('error', (error) => {
        console.error(`WebSocket错误 - 用户: ${userId}, 错误: ${error.message}, 时间: ${new Date().toISOString()}`);
    });
});</code></pre>

            <div class="practice">
                <h4>安全审查清单</h4>
                <p>在部署 WebSocket 应用前，请确认：</p>
                <ul>
                    <li>✅ 使用 WSS 而非 WS 协议</li>
                    <li>✅ 实施了强健的身份验证机制</li>
                    <li>✅ 所有收到的消息都经过验证和清理</li>
                    <li>✅ 已配置适当的速率限制</li>
                    <li>✅ 已实施资源限制（连接超时、消息大小限制）</li>
                    <li>✅ 已配置合适的日志记录</li>
                    <li>✅ 已实施 CORS 保护</li>
                    <li>✅ 已进行漏洞测试（包括DoS和未授权访问测试）</li>
                    <li>✅ 已有安全事件响应计划</li>
                </ul>
            </div>
        </section>

        <section id="java-websocket">
            <h2>6. Java WebSocket 整合</h2>

            <div class="reflection-questions">
                <h4>思考问题</h4>
                <ol>
                    <li>Java 中有哪些实现 WebSocket 的主要技术和框架？</li>
                    <li>JSR 356 规范与 Spring WebSocket 有何异同？</li>
                    <li>在企业应用中，如何选择合适的 Java WebSocket 实现方案？</li>
                    <li>Java WebSocket 应用的部署需要考虑哪些特殊因素？</li>
                    <li>如何测试 Java WebSocket 应用？</li>
                </ol>
                <p><em>在学习本章内容前，请思考这些问题。这将帮助你更好地理解 Java WebSocket 的核心概念和应用场景。</em></p>
            </div>

            <h3>6.1 Java WebSocket API (JSR 356)</h3>
            <p>Java API for WebSocket (JSR 356) 是 Java EE 7 引入的标准规范，提供了在 Java 中创建 WebSocket 应用的官方 API。</p>

            <h4>6.1.1 创建 WebSocket 服务端</h4>
            <p>使用 Java WebSocket API 创建一个 WebSocket 端点非常简单，只需添加几个注解即可：</p>

            <pre><code class="java">package com.example.websocket;

import java.io.IOException;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

import javax.websocket.OnClose;
import javax.websocket.OnError;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;

@ServerEndpoint("/chat")
public class ChatEndpoint {
    
    private static Set&lt;Session&gt; sessions = new CopyOnWriteArraySet&lt;&gt;();
    
    @OnOpen
    public void onOpen(Session session) {
        sessions.add(session);
        System.out.println("新连接建立: " + session.getId());
        broadcastMessage("系统消息：用户 " + session.getId() + " 加入了聊天室");
    }
    
    @OnMessage
    public void onMessage(String message, Session session) {
        System.out.println("收到消息: " + message + " 来自 " + session.getId());
        broadcastMessage("用户 " + session.getId() + ": " + message);
    }
    
    @OnClose
    public void onClose(Session session) {
        sessions.remove(session);
        System.out.println("连接关闭: " + session.getId());
        broadcastMessage("系统消息：用户 " + session.getId() + " 离开了聊天室");
    }
    
    @OnError
    public void onError(Throwable error, Session session) {
        System.err.println("错误发生在会话 " + session.getId() + ": " + error.getMessage());
    }
    
    private void broadcastMessage(String message) {
        for (Session session : sessions) {
            try {
                session.getBasicRemote().sendText(message);
            } catch (IOException e) {
                System.err.println("发送消息失败: " + e.getMessage());
            }
        }
    }
}</code></pre>

            <h4>6.1.2 服务端配置</h4>
            <p>在 Java EE 环境中，WebSocket 端点会被自动扫描并注册，无需额外配置。但在 Servlet 容器（如 Tomcat）中，需要确保在 web.xml 或通过注解配置 WebSocket 支持：</p>

            <pre><code class="java">// 使用编程方式注册端点
import javax.websocket.server.ServerContainer;
import javax.websocket.server.ServerEndpointConfig;
import javax.servlet.ServletContextListener;
import javax.servlet.ServletContextEvent;
import javax.servlet.annotation.WebListener;

@WebListener
public class WebSocketInitializer implements ServletContextListener {
    
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        ServerContainer serverContainer = (ServerContainer) sce.getServletContext()
                .getAttribute("javax.websocket.server.ServerContainer");
        try {
            serverContainer.addEndpoint(ChatEndpoint.class);
            // 或使用配置类
            serverContainer.addEndpoint(ServerEndpointConfig.Builder
                    .create(AdvancedChatEndpoint.class, "/advancedChat")
                    .configurator(new CustomConfigurator())
                    .build());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        // 清理资源
    }
}</code></pre>

            <h4>6.1.3 WebSocket 客户端 API</h4>
            <p>Java WebSocket API 也支持创建客户端应用：</p>

            <pre><code class="java">package com.example.websocket.client;

import java.net.URI;
import javax.websocket.ClientEndpoint;
import javax.websocket.ContainerProvider;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.WebSocketContainer;

@ClientEndpoint
public class WebSocketClient {
    
    private Session session;
    
    public WebSocketClient(URI endpointURI) {
        try {
            WebSocketContainer container = ContainerProvider.getWebSocketContainer();
            container.connectToServer(this, endpointURI);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    @OnOpen
    public void onOpen(Session session) {
        this.session = session;
        System.out.println("已连接到服务器");
    }
    
    @OnMessage
    public void onMessage(String message) {
        System.out.println("收到消息: " + message);
    }
    
    public void sendMessage(String message) {
        try {
            session.getBasicRemote().sendText(message);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    // 使用示例
    public static void main(String[] args) {
        try {
            WebSocketClient client = new WebSocketClient(new URI("ws://localhost:8080/chat"));
            // 等待连接建立
            Thread.sleep(1000);
            // 发送消息
            client.sendMessage("Hello from Java client!");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>

            <h3>6.2 Spring WebSocket</h3>
            <p>Spring 框架提供了对 WebSocket 的强大支持，尤其是与 STOMP 子协议的集成，使得构建复杂的 WebSocket 应用更加简单。</p>

            <h4>6.2.1 Spring WebSocket 配置</h4>
            <p>在 Spring Boot 应用中配置 WebSocket：</p>

            <pre><code class="java">package com.example.websocket.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // 启用简单的内存消息代理
        registry.enableSimpleBroker("/topic", "/queue");
        // 设置应用前缀
        registry.setApplicationDestinationPrefixes("/app");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // 注册 STOMP 端点
        registry.addEndpoint("/ws")
                .setAllowedOrigins("*")
                .withSockJS(); // 启用 SockJS 回退
    }
}</code></pre>

            <h4>6.2.2 控制器和消息处理</h4>
            <p>使用 Spring 的消息映射机制处理 WebSocket 消息：</p>

            <pre><code class="java">package com.example.websocket.controller;

import com.example.websocket.model.ChatMessage;
import com.example.websocket.model.OutputMessage;

import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.stereotype.Controller;

import java.text.SimpleDateFormat;
import java.util.Date;

@Controller
public class ChatController {

    @MessageMapping("/chat")
    @SendTo("/topic/messages")
    public OutputMessage send(ChatMessage message) {
        String time = new SimpleDateFormat("HH:mm:ss").format(new Date());
        return new OutputMessage(message.getFrom(), message.getText(), time);
    }
}

// 消息模型
package com.example.websocket.model;

public class ChatMessage {
    private String from;
    private String text;

    // getters and setters
    public String getFrom() {
        return from;
    }

    public void setFrom(String from) {
        this.from = from;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
}

public class OutputMessage {
    private String from;
    private String text;
    private String time;

    public OutputMessage(String from, String text, String time) {
        this.from = from;
        this.text = text;
        this.time = time;
    }

    // getters and setters
    public String getFrom() {
        return from;
    }

    public void setFrom(String from) {
        this.from = from;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String getTime() {
        return time;
    }

    public void setTime(String time) {
        this.time = time;
    }
}</code></pre>

            <h4>6.2.3 用户认证与消息拦截</h4>
            <p>Spring Security 与 WebSocket 集成，实现认证和消息拦截：</p>

            <pre><code class="java">package com.example.websocket.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.SimpMessageType;
import org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry;
import org.springframework.security.config.annotation.web.socket.AbstractSecurityWebSocketMessageBrokerConfigurer;

@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    @Override
    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
            .simpTypeMatchers(SimpMessageType.CONNECT, SimpMessageType.HEARTBEAT, SimpMessageType.DISCONNECT).permitAll()
            .simpDestMatchers("/app/**").hasRole("USER")
            .simpSubscribeDestMatchers("/topic/**", "/queue/**").hasRole("USER")
            .anyMessage().denyAll();
    }

    @Override
    protected boolean sameOriginDisabled() {
        // 允许跨域
        return true;
    }
}

// 自定义通道拦截器
package com.example.websocket.interceptor;

import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.simp.stomp.StompCommand;
import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
import org.springframework.messaging.support.ChannelInterceptor;
import org.springframework.messaging.support.MessageHeaderAccessor;
import org.springframework.stereotype.Component;

@Component
public class WebSocketInterceptor implements ChannelInterceptor {

    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
        
        if (StompCommand.CONNECT.equals(accessor.getCommand())) {
            // 获取用户认证信息或其他自定义逻辑
            String authToken = accessor.getFirstNativeHeader("X-Auth-Token");
            if (authToken != null) {
                // 验证令牌并设置用户信息
                // accessor.setUser(...)
            }
        }
        
        return message;
    }
}</code></pre>

            <h3>6.3 Spring WebFlux WebSocket</h3>
            <p>Spring WebFlux 提供了响应式 WebSocket 支持，适合构建高并发的 WebSocket 应用：</p>

            <pre><code class="java">package com.example.websocket.reactive;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.HandlerMapping;
import org.springframework.web.reactive.handler.SimpleUrlHandlerMapping;
import org.springframework.web.reactive.socket.WebSocketHandler;
import org.springframework.web.reactive.socket.WebSocketMessage;
import org.springframework.web.reactive.socket.server.support.WebSocketHandlerAdapter;

import java.util.HashMap;
import java.util.Map;

import reactor.core.publisher.Flux;

@Configuration
public class ReactiveWebSocketConfig {

    @Bean
    public HandlerMapping webSocketHandlerMapping() {
        Map<String, WebSocketHandler> map = new HashMap<>();
        map.put("/reactive-socket", new ReactiveWebSocketHandler());

        SimpleUrlHandlerMapping handlerMapping = new SimpleUrlHandlerMapping();
        handlerMapping.setOrder(1);
        handlerMapping.setUrlMap(map);
        return handlerMapping;
    }

    @Bean
    public WebSocketHandlerAdapter handlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
}

class ReactiveWebSocketHandler implements WebSocketHandler {

    @Override
    public reactor.core.publisher.Mono<Void> handle(org.springframework.web.reactive.socket.WebSocketSession session) {
        // 处理传入消息
        Flux<WebSocketMessage> output = session.receive()
                .map(message -> message.getPayloadAsText())
                .map(text -> "响应: " + text)
                .map(session::textMessage);

        return session.send(output);
    }
}</code></pre>

            <h3>6.4 实际应用示例：实时股票交易平台</h3>
            <p>下面是一个使用 Spring Boot 和 WebSocket 构建的股票交易平台后端示例：</p>

            <h4>6.4.1 项目结构</h4>
            <pre><code>src/main/java/com/example/stocktrading/
├── StockTradingApplication.java
├── config/
│   ├── WebSocketConfig.java
│   └── SchedulerConfig.java
├── controller/
│   └── StockController.java
├── model/
│   ├── StockQuote.java
│   └── TradeRequest.java
├── service/
│   ├── StockService.java
│   └── StockQuoteGenerator.java
└── exception/
    └── TradingException.java</code></pre>

            <h4>6.4.2 WebSocket 配置</h4>
            <pre><code class="java">package com.example.stocktrading.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker("/topic");
        registry.setApplicationDestinationPrefixes("/app");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/stock-trading")
               .setAllowedOrigins("*")
               .withSockJS();
    }
}</code></pre>

            <h4>6.4.3 定时推送股票行情</h4>
            <pre><code class="java">package com.example.stocktrading.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import com.example.stocktrading.model.StockQuote;
import com.example.stocktrading.service.StockQuoteGenerator;

import java.util.List;

@Configuration
@EnableScheduling
public class SchedulerConfig {

    @Autowired
    private SimpMessagingTemplate messagingTemplate;
    
    @Autowired
    private StockQuoteGenerator quoteGenerator;
    
    @Scheduled(fixedRate = 2000) // 每2秒更新一次
    public void sendStockQuotes() {
        List<StockQuote> quotes = quoteGenerator.generateRandomQuotes();
        messagingTemplate.convertAndSend("/topic/stock-quotes", quotes);
    }
}</code></pre>

            <h4>6.4.4 控制器处理交易请求</h4>
            <pre><code class="java">package com.example.stocktrading.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Controller;

import com.example.stocktrading.exception.TradingException;
import com.example.stocktrading.model.TradeRequest;
import com.example.stocktrading.model.TradeResponse;
import com.example.stocktrading.service.StockService;

@Controller
public class StockController {

    @Autowired
    private StockService stockService;
    
    @Autowired
    private SimpMessagingTemplate messagingTemplate;
    
    @MessageMapping("/trade")
    public void executeTrade(TradeRequest request) {
        try {
            TradeResponse response = stockService.processTrade(request);
            // 向特定用户发送交易确认
            messagingTemplate.convertAndSendToUser(
                request.getUserId(), 
                "/queue/trade-confirmation", 
                response
            );
            
            // 广播交易更新（不含敏感信息）
            messagingTemplate.convertAndSend(
                "/topic/market-activity", 
                stockService.getMarketUpdate(request.getSymbol())
            );
        } catch (TradingException e) {
            // 发送错误响应
            messagingTemplate.convertAndSendToUser(
                request.getUserId(), 
                "/queue/errors", 
                e.getMessage()
            );
        }
    }
    
    @MessageMapping("/subscribe-symbol")
    @SendTo("/topic/symbols/")
    public void subscribeToSymbol(String symbol) {
        // 用户订阅特定股票的更新
        // 可以在这里记录用户的订阅以便定向推送
        return;
    }
}</code></pre>

            <h4>6.4.5 数据模型</h4>
            <pre><code class="java">package com.example.stocktrading.model;

import java.math.BigDecimal;
import java.time.LocalDateTime;

public class StockQuote {
    private String symbol;
    private BigDecimal price;
    private BigDecimal change;
    private BigDecimal changePercent;
    private long volume;
    private LocalDateTime timestamp;
    
    // 构造函数、getter和setter
}

public class TradeRequest {
    private String userId;
    private String symbol;
    private int quantity;
    private String orderType; // "BUY" or "SELL"
    private BigDecimal limitPrice; // 可选的限价
    
    // 构造函数、getter和setter
}

public class TradeResponse {
    private String tradeId;
    private String status;
    private BigDecimal executedPrice;
    private LocalDateTime executionTime;
    private String message;
    
    // 构造函数、getter和setter
}</code></pre>

            <div class="practice">
                <h4>实践练习</h4>
                <p>实现一个简单的实时聊天应用，包含以下功能：</p>
                <ol>
                    <li>使用 JSR 356 或 Spring WebSocket 创建服务端</li>
                    <li>实现用户加入/离开通知</li>
                    <li>支持一对一私聊和群聊</li>
                    <li>添加基本的用户认证</li>
                    <li>实现消息持久化（可选）</li>
                </ol>
                <p>这个练习将帮助你理解 Java WebSocket 编程的核心概念和最佳实践。</p>
            </div>
        </section>

        <footer>
            <p>Copyright © 2023 Java 学习教程 | 更多教程请访问 <a href="../index.html">首页</a></p>
        </footer>
    </div>
</body>
</html> 